#if DEAL_II_USE_MPI == 1
#include <libparest/parallel/message_log.h>
#include <libparest/parallel/tools.h>

namespace libparest
{

  namespace MessageLog
  {
    namespace MPI
    {
				       /**
					* Maximal character length of a
					* string. Make it large enough
					* to hold the most common cases,
					* yet small enough that not much
					* traffic is generated by
					* sending small strings within
					* large char arrays. This size
					* seems sensible to allow
					* sending everything within one
					* TCP/IP packet. (The size of
					* two ints is subtracted to
					* allow a whole object of type
					* @p{Buffer} to fit into 256
					* bytes, even in view of
					* possibly added padding.)
					*/
      static const unsigned int max_size = 256-4*sizeof(int);
    
				       /**
					* Buffer into which let MPI we
					* write information coming from
					* the outside. We also use it to
					* send, as it can always be
					* casted to a byte (char) type.
					*/
      struct Buffer 
      {
	  unsigned int u;
	  unsigned int priority;
	  char         c[max_size];
      };

      enum Tags {
	    tag_register_relay_object,
	    tag_deregister_relay_object,
	    tag_register_client,
	    tag_deregister_client,
	    tag_put_message
      };



    

      MasterSideRelay::MasterSideRelay (MessageLog::ServerBase &global_message_log,
					::MPI::Intracomm       &communicator,
					Threads::ThreadMutex   &mpi_mutex)
		      :
		      global_message_log (global_message_log),
		      communicator (communicator),
		      mpi_mutex (mpi_mutex)
      {}



      void
      MasterSideRelay::run_event_loop ()
      {
					 
					 
	mpi_mutex.acquire ();
	communicator.Barrier ();
	mpi_mutex.release ();
  
	Buffer buf;
	::MPI::Status status;
	unsigned int relay_objects = 0;
  
	while (true)
	  {
					     
					     
	    MPI_Tools::poll_for_incoming_message (communicator, mpi_mutex);
	    mpi_mutex.acquire ();
	    communicator.Recv (&buf, sizeof(buf), ::MPI::CHAR,
			       ::MPI::ANY_SOURCE, ::MPI::ANY_TAG, status);
	    const unsigned int sender = status.Get_source ();
	    const unsigned int tag    = status.Get_tag ();
	    mpi_mutex.release ();
      
	    switch (tag)
	      {
		case tag_register_client:
		{
		  buf.u = global_message_log.register_client(buf.c);
		  mpi_mutex.acquire ();
		  communicator.Bsend (&buf.u, 1, ::MPI::UNSIGNED, sender,
				      tag_register_client);
		  mpi_mutex.release ();
		  break;
		}

		case tag_deregister_client:
		{
		  global_message_log.deregister_client(buf.u);
		  break;
		}

		case tag_put_message:
		{
		  global_message_log.put_message (buf.u, buf.c, buf.priority);
		  break;
		}

		case tag_register_relay_object:
		{
		  ++relay_objects;
		  break;
		}
	   
		case tag_deregister_relay_object:
		{
		  --relay_objects;
						   
						   
						   
		  if (relay_objects == 0)
		    return;
		  break;
		}		

		default:
		      AssertThrow (false, ExcInternalError());
	      }
	  }
      }




      Server::Server (::MPI::Intracomm     &communicator,
		      const unsigned int    server_rank,
		      Threads::ThreadMutex &mpi_mutex)
		      :
		      communicator (communicator),
		      server_rank (server_rank),
		      mpi_mutex (mpi_mutex)
      {
					 
					 
	mpi_mutex.acquire ();
	communicator.Barrier ();
	mpi_mutex.release ();
  
	Buffer buf;
	mpi_mutex.acquire ();
	communicator.Bsend (&buf, 0, ::MPI::CHAR, server_rank,
			    tag_register_relay_object);
	mpi_mutex.release ();
      }



      Server::~Server ()
      {
	Buffer buf;
					 
					 
					 
	mpi_mutex.acquire ();
	communicator.Bsend (&buf, 0, ::MPI::CHAR, server_rank,
			    tag_deregister_relay_object);
	mpi_mutex.release ();
      }



      unsigned int
      Server::register_client (const std::string &name)
      {
	Assert (name.length() < max_size-1,
		ExcMessageTooLong (name.size(), name));

	Buffer buf;
	for (unsigned int i=0; i<name.length(); ++i)
	  buf.c[i] = name[i];
	buf.c[name.length()] = 0;

					 
	mpi_mutex.acquire ();
	communicator.Bsend (&buf, sizeof(buf), ::MPI::CHAR,
			    server_rank, tag_register_client);
	mpi_mutex.release ();
  
					 
	MPI_Tools::poll_for_incoming_message (communicator, mpi_mutex);

	::MPI::Status status;
	mpi_mutex.acquire ();
	communicator.Recv (&buf.u, 1, ::MPI::UNSIGNED, server_rank,
			   tag_register_client, status);
	Assert (status.Get_count(::MPI::UNSIGNED) == 1, ExcInternalError());
	mpi_mutex.release ();

	return buf.u;
      }



      void
      Server::deregister_client (const unsigned int id)
      {
	Buffer buf;
	buf.u = id;
	mpi_mutex.acquire ();
	communicator.Bsend (&buf, sizeof(buf), ::MPI::CHAR, server_rank,
			    tag_deregister_client);
	mpi_mutex.release ();
      }



      void
      Server::put_message (const unsigned int  id,
			   const std::string  &message,
			   const unsigned int  priority)
      {
					 
					 
					 
					 
					 
	if (apply_filters ("", message, priority) == true)
	  return;

					 
	Buffer buf;
	buf.u = id;
	buf.priority = priority;
  
	Assert (message.length() < max_size-1,
		ExcMessageTooLong (message.size(), message));
	for (unsigned int i=0; i<message.length(); ++i)
	  buf.c[i] = message[i];
	buf.c[message.length()] = 0;

	mpi_mutex.acquire ();
	communicator.Bsend (&buf, sizeof(buf), ::MPI::CHAR, server_rank,
			    tag_put_message);
	mpi_mutex.release ();
      }
 
    }
  }
 
}

#endif
