<?xml version="1.0"?>
<!DOCTYPE flagsdescription SYSTEM "http://www.spec.org/dtd/cpuflags2.dtd">
<flagsdescription>

<!--
######################################################################################################
       This file is centrally maintained.  You should not have
       to edit it; if you see a need for improvements, please
       write to SPEC CPU(R) technical support (see
       http://www.spec.org/cpu2017/Docs/techsupport.html )

       If you DO change it, you MUST change the filename tag
       just below, or your changes may be lost!
######################################################################################################
-->

<filename>Intel-ic17.0-official-windows-revF-spec</filename>

<title>SPEC CPU&reg;2017 Flag Description for the Intel&reg; C/C++ and Fortran Compiler</title>


<submit_command>
<![CDATA[ 
<dl>                 
  <dt><b>submit= specperl -e "system sprintf qq{start /b /wait /affinity %x %s}, (1&lt;&lt;$SPECCOPYNUM), qq{ $command } " </b></dt>
   <dd>When running multiple copies of benchmarks, the SPEC config file feature <b>submit</b> is used to cause individual jobs to be bound to 
   specific processors. This specific submit command is used for Windows. <br />
   Here is a brief guide to understanding the specific command which will be found in the config file:
   <ul>
   <li><b>start /b /wait /affinity mask command </b>: <br/>
   The start command is used to launch a new COMMAND with a given CPU 
   affinity. The CPU affinity is represented as a bitmask, with the 
   lowest order bit corresponding to the first logical CPU and highest
   order bit corresponding to the last logical CPU. The process is only allowed to run 
   on a particular logical processor when the corresponding bit in the mask has been set to 1. <br/>
   </li>
   <li><b>mask</b>: The bitmask (in hexadecimal) corresponding to a specific
    SPECCOPYNUM. For example, the mask value for the first copy of a 
    rate run will be 0x00000001, for the second copy of the rate will 
    be 0x00000010 etc. Thus, the first copy of the rate run will have a
    CPU affinity of CPU0, the second copy will have the affinity CPU1 
    etc.</li>
   <li><b>command</b>: Program to be started, in this case, the benchmark instance 
    to be started.</li>
   </ul>
   </dd>		 
</dl>
]]> 
</submit_command>



<sw_environment>
<![CDATA[
<dl>

  <dt><b>KMP_STACKSIZE </b></dt>
  <dd> Specify stack size to be allocated for each thread.  </dd>

  <dt><b>KMP_AFFINITY</b></dt>
  <dd>Syntax: KMP_AFFINITY=[&#60;modifier&#62;,...]&#60;type&#62;[,&#60;permute&#62;][,&#60;offset&#62;]<br/>
  The value for the environment variable KMP_AFFINITY affects how the threads from an auto-parallelized program are scheduled across processors. <br/>
  It applies to binaries built with -openmp and -parallel (Linux and Mac OS X) or /Qopenmp and /Qparallel (Windows). <br/>
  modifier:<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;<i>granularity=fine</i> Causes each OpenMP thread to be bound to a single thread context.<br/>
  type:<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;<i>compact</i> Specifying compact assigns the OpenMP thread &lt;n&gt;+1 to a free thread context as close as possible to the thread context where the &lt;n&gt; OpenMP thread was placed.<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;<i>scatter</i>  Specifying scatter distributes the threads as evenly as possible across the entire system.<br/>
  permute: The permute specifier is an integer value controls which levels are most significant when sorting the machine topology map. A value for permute forces the mappings to make the specified number of most significant levels of the sort the least significant, and it inverts the order of significance.<br/>
  offset: The offset specifier indicates the starting position for thread assignment.<br/><br/>
  
  <b>Please see the <i>Thread Affinity Interface</i> article in the Intel Composer XE Documentation for more details.</b> <br/><br/></dd>
  
  <dd>Example: <b>KMP_AFFINITY=granularity=fine,scatter </b><br/>
	Specifying granularity=fine selects the finest granularity level and causes each OpenMP or auto-par thread to be bound to a single thread context. <br/>
  This ensures that there is only one thread per core on cores supporting HyperThreading Technology<br/>
  Specifying scatter distributes the threads as evenly as possible across the entire system. <br/> 
  Hence a combination of these two options, will spread the threads evenly across sockets, with one thread per physical core. <br/><br/> </dd>
  <dd>Example: <b>KMP_AFFINITY=compact,1,0</b><br/>
	Specifying <b><i>compact</i></b> will assign the n+1 thread to a free thread context as close as possible to thread n. <br/> 
	A default granularity=core is implied if no granularity is explicitly specified. <br/>
  Specifying <i>1,0</i> sets permute and offset values of the thread assignment. <br/>
  With a permute value of 1, thread n+1 is assigned to a consecutive core. With an offset of 0, the process's first thread 0 will be assigned to thread 0.<br/> 
  The same behavior is exhibited in a multisocket system.</dd>


  <dt><b>OMP_NUM_THREADS </b></dt>
  <dd>Sets the maximum number of threads to use for OpenMP* parallel regions if no 
  other value is specified in the application. This environment variable 
  applies to both -openmp and -parallel (Linux and Mac OS X) or /Qopenmp and /Qparallel (Windows).
  Example syntax on a Linux system with 8 cores:
  export OMP_NUM_THREADS=8 </dd>

</dl>
]]>
</sw_environment>



<header>
<![CDATA[
<p style="text-align: left; color: red; font-size: larger; background-color: black">
 Copyright &copy; 2006 Intel Corporation.  All Rights Reserved.</p>
]]>
</header>

<!--
******************************************************************************************************
* Compilers
******************************************************************************************************
-->

<flag name="compiler_path_eater"
     class="compiler"
     regexp="\S+/((?:icl|icc|icpc|ifort)\S*)">
   <display enable="0" />
   <include text="$1" />
   <example>/path/to/{icc|icpc|ifort}</example>
</flag>

<!-- base compiler invocation -->
<flag name="intel_ifort" class="compiler" regexp="ifort(?:\.exe)?(?=\s|$)">
   <example>ifort</example>
   <![CDATA[
      <p>Invoke the Intel Fortran compiler in default mode (IA32 or Intel 64 as specified in the notes)</p>
   ]]>
</flag>

<flag name="intel_icc" class="compiler" regexp="ic[cl](?:\.exe)?(?=\s|$)">
   <example>icl</example>
   <![CDATA[
      <p>Invoke the Intel C/C++ compiler in default mode (IA32 or Intel 64 as specified in the notes)</p>
   ]]>
</flag>

<flag name="intel_icpc" class="compiler" regexp="icpc(?:\.exe)?(?=\s|$)">
   <example>icl</example>
   <![CDATA[
      <p>Invoke the Intel C/C++ compiler in default mode (IA32 or Intel 64 as specified in the notes)</p>
   ]]>
</flag>

<flag name="intel_icc_64bit" class="compiler" regexp="C:\\Program.*?intel64/icl.exe(?=\s|$)">

   <![CDATA[
      <p>Invoke the Intel C/C++ compiler in Intel 64 mode</p>
   ]]>

</flag>

<!-- MSVC compatibility level -->
<flag name="intel_icc_vc14" class="compiler" regexp="[/-]Qvc14(?=\s|$)">

   <![CDATA[
      <p>Invoke the compiler with Visual Studio 2015 compatibility.</p>
   ]]>

</flag>

<flag name="intel_icc_vc12" class="compiler" regexp="[/-]Qvc12(?=\s|$)">

   <![CDATA[
      <p>Invoke the compiler with Visual Studio 2013 compatibility.</p>
   ]]>

</flag>

<flag name="intel_icc_vc10" class="compiler" regexp="[/-]Qvc10(?=\s|$)">

   <![CDATA[
      <p>Invoke the compiler with Visual Studio 2010 compatibility.</p>
   ]]>

</flag>

<!-- data model selection -->
<flag name="intel_icc_32" class="compiler" regexp="[/-]Qm32(?=\s|$)">

   <![CDATA[
      <p>Invoke the compiler in 32bit mode</p>
   ]]>

</flag>

<flag name="intel_icc_64" class="compiler" regexp="[/-]Qm64(?=\s|$)">

   <![CDATA[
      <p>Invoke the compiler in 64bit mode</p>
   ]]>

</flag>

<!-- language standard levels -->
<flag name="intel_compiler_openmp" class="optimization" regexp="[/-]qopenmp(?=\s|$)" parallel="yes">
   <![CDATA[
      <p>Enable support for explicit parallelization via OpenMP.</p>
   ]]>

</flag>

<flag name="intel_compiler_c99_mode" class="compiler" regexp="[/-]Qstd=c99(?=\s|$)">
   <![CDATA[
      <p>Invoke the Intel C/C++ compiler in C99 mode.</p>
   ]]>

</flag>

<flag name="intel_icc_cxx11" class="compiler" regexp="[/-]Qstd=c\+\+11(?=\s|$)">

   <![CDATA[
      <p>Invoke the Intel C/C++ compiler in C++11 mode.</p>
   ]]>

</flag>

<!-- compiler input file types -->
<flag name="intel_icc_tc" class="compiler" regexp="[/-]TC(?=\s|$)">

   <![CDATA[
      <p>Specify that input files are C regardless of file extension.</p>
   ]]>

</flag>

<flag name="intel_icc_vc14_64_cxx11" class="compiler" regexp="[/-]TP(?=\s|$)">

   <![CDATA[
      <p>Specify that input files are C++ regardless of file extension.</p>
   ]]>

</flag>


<flag name="intel_compiler_64bit_h_dir" class="other" regexp="[/-]I&quot;C:/Program Files \(x86\)/IntelSWTools/compilers_and_libraries_\d+/windows/compiler/include/intel64&quot;">
  <example>/I&quot;C:/Program Files \(x86\)/IntelSWTools/compilers_and_libraries_2017/windows/compiler/include/intel64&quot;</example>

   <![CDATA[
      <p>Location of the Intel 64 version of the Intel Compiler headers</p>
   ]]>

</flag>


<flag name="intel_compiler_h_dir" class="other" regexp="[/-]I&quot;C:/Program Files \(x86\)/IntelSWTools/compilers_and_libraries_\d+/windows/compiler/include&quot;">
  <example>/I&quot;C:/Program Files \(x86\)/IntelSWTools/compilers_and_libraries_2017/windows/compiler/include&quot;</example>

   <![CDATA[
      <p>Location of the Intel Compiler headers</p>
   ]]>

</flag>


<flag name="windows_sdk_ucrt_h_dir" class="other" regexp="[/-]I&quot;C:/Program Files \(x86\)/Windows Kits/\d+/Include/[\d.]+&quot;/ucrt">
  <example>/I&quot;C:/Program Files \(x86\)/Windows Kits/10/Include/10.1.2.3?&quot;/ucrt</example>

   <![CDATA[
      <p>Location of the Windows SDK ucrt headers</p>
   ]]>

</flag>


<flag name="windows_sdk_um_h_dir" class="other" regexp="[/-]I&quot;C:/Program Files \(x86\)/Windows Kits/\d+/Include/[\d.]+&quot;/um">
  <example>/I&quot;C:/Program Files \(x86\)/Windows Kits/10/Include/10.1.2.3?&quot;/um</example>

   <![CDATA[
      <p>Location of the Windows SDK um headers</p>
   ]]>

</flag>

<flag name="windows_sdk_64bit_lib_dirs" class="other" regexp="[/-]link [/-]LIBPATH[:=]&quot;C:/Program Files \(x86\)/Windows Kits/10/Lib/[\d.]+&quot;/ucrt/x64 [/-]LIBPATH[:=]&quot;C:/Program Files \(x86\)/Windows Kits/10/Lib/[\d.]+&quot;/um/x64">
  <example>/link /LIBPATH=&quot;C:/Program Files \(x86\)/Windows Kits/10/Lib/10.1.2.3&quot;/ucrt/x64 /LIBPATH=&quot;C:/Program Files \(x86\)/Windows Kits/10/Lib/10.1.2.3&quot;/um/x64</example>

   <![CDATA[
      <p>Location of the Windows SDK urct and um link libraries for 64bit targets</p>
   ]]>

</flag>

<flag name="verbose_linker_output" class="other" regexp="[/-]VERBOSE">

   <![CDATA[
      <p>Report verbose linker output to confirm compile time linker behavior</p>
   ]]>

</flag>


<flag name="intel_compiler_64bit_lib_dir" class="other" regexp="[/-]link [/-]LIBPATH:C:[\\/]Program Files.*?[\\/]Composer.*?XE.*?[\\/]compiler[\\/]lib[\\/]intel64(?=\s|$)">
  <example>/link /LIBPATH:C:\\Program Files\\Composer XE 2017/compiler/lib/intel64</example>
   <![CDATA[
      <p>Location of the Intel 64 version of the Intel Compiler libraries</p>
   ]]>

</flag>

<flag name="ms_vs10_compiler_lib_dir" class="other" regexp="[/-]link\s+[/-]LIBPATH:.*?[\\/]Microsoft Visual Studio [\d.]+[\\/]VC[\\/]lib(?=\s|$)">
  <example>/link /LIBPATH:C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/lib</example>
   <![CDATA[
      <p>Location of the Microsoft Visual Studio libraries</p>
   ]]>

</flag>

<flag name="ms_vs_compiler_64bit_lib_dir" class="other" regexp="[/-]link\s+[/-]LIBPATH:.*?[\\/]Microsoft Visual Studio [\d.]+[\\/]VC[\\/]lib[\\/]AMD64(?=\s|$)">
  <example>/link /LIBPATH:C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/lib/AMD64</example>
   <![CDATA[
      <p>Location of the 64-bit versions of the Microsoft Visual Studio libraries</p>
   ]]>

</flag>

<flag name="ms_vs_compiler_additional_lib_dir" class="other" regexp="[/-]link\s+[/-]LIBPATH:.*?[\\/]Microsoft SDKs[\\/]Windows[\\/]v[\d.A-Z]+[\\/]lib[\\/]x64(?=\s|$)">
  <example>/link /LIBPATH:C:/Program Files (x86)/Microsoft SDKs/Windows/v7.0A/lib/x64</example>
   <![CDATA[
      <p>Location of additional Microsoft Visual Studio libraries</p>
   ]]>

</flag>

<flag name="ms_vs_compiler_additional_lib_dir2" class="other" regexp="[/-]link\s+.*?Libd(?=\s|$)">

   <![CDATA[
      <p>Location of additional Microsoft Visual Studio libraries</p>
   ]]>

</flag>

<!--
******************************************************************************************************
* Portability
******************************************************************************************************
-->
<flag name="lowercase_routine_name" class="portability" regexp="(?:/\S+/)?.names:lowercase(?=\s|$)">

   <![CDATA[
      <p>For mixed-language benchmarks, tell the compiler to convert routine names to 
      lowercase for compatibility</p>
   ]]>

</flag>


<flag name="be_conversion" class="portability" regexp="[/-]convert:big_endian">

   <![CDATA[
      <p>Specify the big endian format for unformatted files containing numeric data</p>
   ]]>

</flag>

<flag name="lowercase_routine_name1" class="portability" regexp="(?:/\S+/)?.Qlowercase(?=\s|$)">

   <![CDATA[
      <p>For mixed-language benchmarks, tell the compiler to convert routine names to 
      lowercase for compatibility</p>
   ]]>

</flag>

<flag name="add-underscore_to_routine_name" class="portability" regexp="(?:/\S+/)?\/assume\:underscore(?=\s|$)">

   <![CDATA[
      <p>For mixed-language benchmarks, tell the compiler to assume that routine 
      names end with an underscore</p>
   ]]>

</flag>

<flag name="workaround_for_incompat_commas_in_macros" class="portability" regexp="[/-]Qoption.*?ms.incompat.treatment.of.commas.in.macros(?=\s|$)">
      Tell the compiler to work around incompatible treatment of commas in macros, in Visual Studio 2010.
</flag>

<flag name="winsock_lib" class="portability" regexp="ws2_32.lib(?=\s|$)">

   <![CDATA[
      <p>The winsock2 link library. Used for linking ntohl(...) in [5|6]21.wrf_[r|s]</p>
   ]]>

</flag>


<flag name="shell32_lib" class="portability" regexp="shell32.lib(?=\s|$)">

   <![CDATA[
      <p>The shell32 link library. Used for 526.blender_r portability</p>
   ]]>

</flag>

<flag name="advapi32_lib" class="portability" regexp="advapi32.lib(?=\s|$)">

   <![CDATA[
      <p>The advapi32 link library. Used for 526.blender_r portability</p>
   ]]>

</flag>

<flag name="user32_lib" class="portability" regexp="user32.lib(?=\s|$)">

   <![CDATA[
      <p>The user32 link library. Used for 526.blender_r portability</p>
   ]]>

</flag>


<flag name="assume_underscore" class="portability" regexp="[/-]assume[:=]underscore(?=\s|$)">

   <![CDATA[
      <p>Specifies assumption for the code generator to use underscores on symbols</p>
   ]]>

</flag>


<flag name="force_uchars" class="portability" regexp="[/-]J(?=\s|$)">

   <![CDATA[
      <p>Forces usage of unsigned chars.</p>
   ]]>

</flag>
<!--
******************************************************************************************************
* Optimizations
******************************************************************************************************
-->
<flag name="f-O1" class="optimization" regexp="[/-]O1(?=\s|$)">
      
   <![CDATA[
      <p>Enables optimizations for speed and disables some optimizations that <br />
         increase code size and affect speed. <br />
         To limit code size, this option: <br />
         - Enables global optimization; this includes data-flow analysis, 
           code motion, strength reduction and test replacement, split-lifetime
           analysis, and instruction scheduling. <br />
         - Disables intrinsic recognition and intrinsics inlining. <br />

         The O1 option may improve performance for applications with very large 
         code size, many branches, and execution time not dominated by code within loops. <br />
         
         On IA-32 Windows platforms, -O1 sets the following:</p>
         <p style="margin-left: 25px">
         /Qunroll0, /Oi-, /Op-, /Oy, /Gy, /Os, /GF (/Qvc7 and above), 
         /Gf (/Qvc6 and below), /Ob2, and /Og</p>
   ]]>

   <include flag="f-Qunroll"/>
   <include flag="f-Oi-"/>
   <include flag="f-Op-"/>
   <include flag="f-Oy"/>
   <include flag="f-Gy"/>
   <include flag="f-Os"/>
   <include flag="f-GF"/>
   <include flag="f-Gf"/>
   <include flag="f-Ob_n"/>
   <include flag="f-Og"/>
   
</flag>

<flag name="f-O2" class="optimization" regexp="[/-]O2(?=\s|$)">

   <![CDATA[
      <p>Enables optimizations for speed. This is the generally recommended 
      optimization level. This option also enables: <br />
      - Inlining of intrinsics<br />
      - Intra-file interprocedural optimizations, which include: <br />
        - inlining<br />
        - constant propagation<br />
        - forward substitution<br />
        - routine attribute propagation<br />
        - variable address-taken analysis<br />
        - dead static function elimination<br />
        - removal of unreferenced variables<br />
      - The following capabilities for performance gain: <br /> 
        - constant propagation<br />
        - copy propagation<br />
        - dead-code elimination<br />
        - global register allocation<br />
        - global instruction scheduling and control speculation<br />
        - loop unrolling<br />
        - optimized code selection<br />
        - partial redundancy elimination<br />
        - strength reduction/induction variable simplification<br />
        - variable renaming<br />
        - exception handling optimizations<br />
        - tail recursions<br />
        - peephole optimizations<br />
        - structure assignment lowering and optimizations<br />
        - dead store elimination<br />
      </p>

      <p>On IA-32 Windows platforms, -O2 sets the following:</p>
         <p style="margin-left: 25px">
         /Og, /Oi-, /Os, /Oy, /Ob2, /GF (/Qvc7 and above), /Gf (/Qvc6 
         and below), /Gs, and /Gy.</p>
   ]]> 

   <include flag="f-Oi-"/>
   <include flag="f-Gs"/>
   <include flag="f-Oy"/>
   <include flag="f-Gy"/>
   <include flag="f-Os"/>
   <include flag="f-GF"/>
   <include flag="f-Gf"/>
   <include flag="f-Ob_n"/>
   <include flag="f-Og"/>
   <include flag="f-O1"/> 
</flag>

<flag name="f-O3" class="optimization" regexp="[/-]O3(?=\s|$)">

   <![CDATA[
      <p>Enables O2 optimizations plus more aggressive optimizations, 
         such as prefetching, scalar replacement, and loop and memory 
         access transformations. Enables optimizations for maximum speed,   
         such as: <br />
         - Loop unrolling, including instruction scheduling<br />
         - Code replication to eliminate branches<br />
         - Padding the size of certain power-of-two arrays to allow 
           more efficient cache use.<br />
         On IA-32 and Intel EM64T processors, when O3 is used with options 
         -ax or -x (Linux) or with options /Qax or /Qx (Windows), the compiler 
         performs more aggressive data dependency analysis than for O2, which 
         may result in longer compilation times. <br />
         The O3 optimizations may not cause higher performance unless loop and 
         memory access transformations take place. The optimizations may slow 
         down code in some cases compared to O2 optimizations.  <br />
         The O3 option is recommended for applications that have loops that heavily 
         use floating-point calculations and process large data sets. On IA-32 
         Windows platforms, -O3 sets the following:</p>
         <p style="margin-left: 25px">
         /GF (/Qvc7 and above), /Gf (/Qvc6 and below), and /Ob2</p>
   ]]> 

   <include flag="f-GF"/>
   <include flag="f-Gf"/>
   <include flag="f-Ob_n"/>
   <include flag="f-O2"/>

</flag>

<flag name="f-opt-mem-layout-trans" class="optimization" regexp="[/-]Qopt-mem-layout-trans[:=](\d+)(?=\s|$)"> 
	<example>/Qopt-mem-layout-trans=3</example> 
<ex_replacement>3</ex_replacement> 
   <![CDATA[ 
      <p> Controls the level of memory layout transformations performed by the compiler. This option can improve cache reuse and cache locality.</p> 
      <ul> 
        <li>0: Disables memory layout transformations. This is the same as specifying -no-opt-mem-layout-trans </li> 
        <li>1: Enables basic memory layout transformations like structure splitting, structure peeling, field inlining, field reordering, array field transpose, increase field alignment etc. </li> <li>2: Enables more memory layout transformations like advanced structure splitting. This is the same as specifying -opt-mem-layout-trans </li> 
        <li>3: Compiler is more aggressive in using memory layout transformations. You should only use this setting if your system has more than 4GB of physical memory per core. </li> 
     </ul> 
     ]]>
</flag>

<flag name="f-Qunroll" class="optimization" regexp="[/-]Qunroll(\d+)(?=\s|$)">
<example>-Qunroll&lt;n&gt;</example> 
This option sets the maximum number of times a loop can be unrolled, to $1.

<ex_replacement> n. For example, -unroll1 will unroll loops just once. To disable loop unrolling, use -unroll0. </ex_replacement>

</flag>

<flag name="f-par-schedule" class="optimization" parallel="yes" regexp="[/-]Qpar-schedule-static\:(\d+)(?=\s|$)">
   <![CDATA[
<p>The -par-schedule option lets you specify a scheduling algorithm or a tuning method for loop iterations.<br /> 
It specifies how iterations are to be divided among the threads of the team. This option affects performance <br />
tuning and can provide better performance during auto-parallelization.</p>
   ]]> 

<example>-par-schedule-static:n</example>
   <![CDATA[
-par-schedule-static=n tells the compiler to divide iterations into contiguous pieces (chunks) of size n. <br />
The chunks are assigned to threads in the team in a round-robin fashion in the order of the thread number. <br />
Note that the last chunk to be assigned may have a smaller number of iterations. If n is not specified, <br />
the iteration space is divided into chunks that are approximately equal in size, and each thread is assigned at most one chunk.<br />
   ]]> 

<ex_replacement> n. For example, -par-schedule-static:32768 will split iterations into chunks of size 32768. </ex_replacement>

</flag>

<flag name="f-Qip" class="optimization" regexp="[/-]Qip(?=\s|$)">
This option enables additional interprocedural optimizations for single 
file compilation. These optimizations are a subset of full intra-file 
interprocedural optimizations. One of these optimizations enables the 
compiler to perform inline function expansion for calls to functions 
defined within the current source file.
</flag>

<flag name="f-Qipo" class="optimization" regexp="[/-]Qipo(?=\s|$)">
   <![CDATA[
      <p>Multi-file ip optimizations that includes:<br />
       - inline function expansion<br />
       - interprocedural constant propogation<br />
       - dead code elimination<br />
       - propagation of function characteristics<br />
       - passing arguments in registers<br />
       - loop-invariant code motion</p>
   ]]> 
</flag>

<flag name="f-fast" class="optimization" regexp="[/-]fast(?=\s|$)">

   <![CDATA[
      <p>The -fast option enhances execution speed across the entire program 
      by including the following options that can improve run-time performance:</p>

      <p style="text-indent: -45px;margin-left: 45px">
      -O3&nbsp;&nbsp;&nbsp;(maximum speed and high-level optimizations)</p>
      <p style="text-indent: -45px;margin-left: 45px"> 
      -Qipo&nbsp;(enables interprocedural optimizations across files)</p>
      <p style="text-indent: -45px;margin-left: 45px">  
      -QxSSSE3&nbsp;&nbsp;(generate code specialized for Intel(R) Core(TM)2 Duo processors, Intel(R) Core(TM)2 Quad processors 
                      and  Intel(R) Xeon(R) processors with SSSE3)</p>
      <p style="text-indent: -45px;margin-left: 45px"> 
      -Qprec-div-&nbsp;(disable -prec-div)
             where -Qprec-div improves precision of FP divides (some speed impact)</p>
   
      <p>To override one of the options set by /fast, specify that option after the 
      -fast option on the command line. The exception is the xT or QxT option
      which can't be overridden. The options set by /fast may change from 
      release to release.</p>
   ]]> 

   <include flag="f-O3"/>
   <include flag="f-Qipo"/>
   <include flag="f-QxSSSE3"/>
   <include flag="f-Qprec-div-"/>
</flag>

<flag name="f-static" class="compiler" regexp="[/-]static(?=\s|$)">
         	 Compiler option to statically link in libraries at link time
</flag>

<flag name="f-fno-strict-overflow" class="optimization" regexp="[/-]fno-strict-overflow(?=\s|$)">
	<![CDATA[
           <p>Tells the compiler to remove the assumption that source code follows c99 signed overflow rules.</p>
	]]>
</flag>

<flag name="f-QxHost" class="optimization" regexp="(?i)[/-]QxHost(?=\s|$)">

   <![CDATA[
      <p>This option tells the compiler to generate instructions for the highest instruction set available on the compilation host processor. 
         The instructions generated by Host differ depending on the compilation host processor.
      </p>
   ]]>

</flag>
<flag name="f-QxCOMMON-AVX512" class="optimization" regexp="[/-]QxCOMMON-AVX512(?=\s|$)">

   <![CDATA[

      <p>Code is optimized for Intel(R) processors with support for COMMON-AVX512 instructions.
      The resulting code may contain unconditional use of features that are not supported
      on other processors. This option also enables new optimizations in addition to
      Intel processor-specific optimizations including advanced data layout and code
      restructuring optimizations to improve memory accesses for Intel processors.</p>

      <p> Do not use this option if you are executing a program on a processor that
      is not an Intel processor. If you use this option on a non-compatible processor
      to compile the main program (in Fortran) or the function main() in C/C++, the
      program will display a fatal run-time error if they are executed on unsupported
      processors. </p>

   ]]>

</flag>

<flag name="f-QxCORE-AVX512" class="optimization" regexp="[/-]QxCORE-AVX512(?=\s|$)">

   <![CDATA[

      <p>Code is optimized for Intel(R) processors with support for CORE-AVX512 instructions.
      The resulting code may contain unconditional use of features that are not supported
      on other processors. This option also enables new optimizations in addition to
      Intel processor-specific optimizations including advanced data layout and code
      restructuring optimizations to improve memory accesses for Intel processors.</p>

      <p> Do not use this option if you are executing a program on a processor that
      is not an Intel processor. If you use this option on a non-compatible processor
      to compile the main program (in Fortran) or the function main() in C/C++, the
      program will display a fatal run-time error if they are executed on unsupported
      processors. </p>

   ]]>

</flag>

<flag name="f-QxMIC-AVX512" class="optimization" regexp="[/-]QxMIC-AVX512(?=\s|$)">

   <![CDATA[

      <p>Code is optimized for Intel(R) processors with support for MIC-AVX512 instructions.
      The resulting code may contain unconditional use of features that are not supported
      on other processors. This option also enables new optimizations in addition to
      Intel processor-specific optimizations including advanced data layout and code
      restructuring optimizations to improve memory accesses for Intel processors.</p>

      <p> Do not use this option if you are executing a program on a processor that
      is not an Intel processor. If you use this option on a non-compatible processor
      to compile the main program (in Fortran) or the function main() in C/C++, the
      program will display a fatal run-time error if they are executed on unsupported
      processors. </p>

   ]]>

</flag>

<flag name="f-QxCORE-AVX2" class="optimization" regexp="[/-]QxCORE-AVX2(?=\s|$)">

   <![CDATA[

      <p>Code is optimized for Intel(R) processors with support for AVX2 instructions.
      The resulting code may contain unconditional use of features that are not supported
      on other processors. This option also enables new optimizations in addition to
      Intel processor-specific optimizations including advanced data layout and code
      restructuring optimizations to improve memory accesses for Intel processors.</p>

      <p> Do not use this option if you are executing a program on a processor that
      is not an Intel processor. If you use this option on a non-compatible processor
      to compile the main program (in Fortran) or the function main() in C/C++, the
      program will display a fatal run-time error if they are executed on unsupported
      processors. </p>

   ]]>

</flag>

<flag name="f-QxAVX" class="optimization" regexp="[/-]QxAVX(?=\s|$)">

   <![CDATA[

      <p>Code is optimized for Intel(R) processors with support for AVX instructions.
      The resulting code may contain unconditional use of features that are not supported
      on other processors. This option also enables new optimizations in addition to
      Intel processor-specific optimizations including advanced data layout and code
      restructuring optimizations to improve memory accesses for Intel processors.</p>

      <p> Do not use this option if you are executing a program on a processor that
      is not an Intel processor. If you use this option on a non-compatible processor
      to compile the main program (in Fortran) or the function main() in C/C++, the
      program will display a fatal run-time error if they are executed on unsupported
      processors. </p>

   ]]>

</flag>

<flag name="f-QxSSE42" class="optimization" regexp="[/-]QxSSE4.2(?=\s|$)">

   <![CDATA[

      <p>Code is optimized for Intel(R) processors with support for SSE 4.2 instructions.
      The resulting code may contain unconditional use of features that are not supported
      on other processors. This option also enables new optimizations in addition to
      Intel processor-specific optimizations including advanced data layout and code
      restructuring optimizations to improve memory accesses for Intel processors.</p>

      <p> Do not use this option if you are executing a program on a processor that
      is not an Intel processor. If you use this option on a non-compatible processor
      to compile the main program (in Fortran) or the function main() in C/C++, the
      program will display a fatal run-time error if they are executed on unsupported
      processors. </p>

   ]]>

</flag>

<flag name="f-QxSSE41" class="optimization" regexp="[/-]QxSSE4.1(?=\s|$)">

   <![CDATA[

      <p>Code is optimized for Intel(R) processors with support for SSE 4.1 instructions.
      The resulting code may contain unconditional use of features that are not supported
      on other processors. This option also enables new optimizations in addition to
      Intel processor-specific optimizations including advanced data layout and code
      restructuring optimizations to improve memory accesses for Intel processors.</p>

      <p> Do not use this option if you are executing a program on a processor that
      is not an Intel processor. If you use this option on a non-compatible processor
      to compile the main program (in Fortran) or the function main() in C/C++, the
      program will display a fatal run-time error if they are executed on unsupported
      processors. </p>

   ]]>

</flag>

<flag name="f-QxSSSE3" class="optimization" regexp="[/-]QxSSSE3(?=\s|$)">

   <![CDATA[

      <p>Code is optimized for Intel(R) processors with support for Supplemental SSE 3 instructions.
      The resulting code may contain unconditional use of features that are not supported
      on other processors. This option also enables new optimizations in addition to
      Intel processor-specific optimizations including advanced data layout and code
      restructuring optimizations to improve memory accesses for Intel processors.</p>

      <p> Do not use this option if you are executing a program on a processor that
      is not an Intel processor. If you use this option on a non-compatible processor
      to compile the main program (in Fortran) or the function main() in C/C++, the
      program will display a fatal run-time error if they are executed on unsupported
      processors. </p>

   ]]>

</flag>

<flag name="f-archSSE2" class="optimization" regexp="[/-]arch:SSE2(?=\s|$)">

    <![CDATA[       
      <p>Code is optimized for Intel Pentium 4 and compatible processors
      that supporting Streaming SIMD Extensions 2; this is the default for Intel EM64T systems. 
      The resulting code may contain unconditional use of features that are not supported on 
      other processors. </p>
    ]]> 
  
</flag>

<flag name="f-archSSE3" class="optimization" regexp="[/-]arch:SSE3(?=\s|$)">

    <![CDATA[       
      <p>Code is optimized for the Intel(R) Core(TM) processor family. Code is expected to run properly on any processor that supports SSE3, SSE2 and SSE
      instruction sets </p>
    ]]> 
  
</flag>

<flag name="f-archAVX" class="optimization" regexp="[/-]arch:AVX(?=\s|$)">

    <![CDATA[       
      <p>Code is optimized for the Intel(R) Core(TM) processor family. Code is expected to run properly on any processor that supports AVX, SSE3, SSE2 and SSE
      instruction sets </p>
    ]]> 
  
</flag>

<flag name="f-QxSSE42ATOM" class="optimization" regexp="[/-]QxATOM_SSE4.2(?=\s|$)">

   <![CDATA[

      <p>Code is optimized for Intel(R) Atom processors with support for SSE4.2 instructions.
      The resulting code may contain unconditional use of features that are not supported
      on other processors. This option also enables new optimizations in addition to
      Intel processor-specific optimizations including advanced data layout and code
      restructuring optimizations to improve memory accesses for Intel processors.</p>

      <p> Do not use this option if you are executing a program on a processor that
      is not an Intel processor. If you use this option on a non-compatible processor
      to compile the main program (in Fortran) or the function main() in C/C++, the
      program will display a fatal run-time error if they are executed on unsupported
      processors. </p>

   ]]>

</flag>

<flag name="f-QxSSSE3ATOM" class="optimization" regexp="[/-]QxSSSE3_ATOM(?=\s|$)">

   <![CDATA[

      <p>Code is optimized for Intel(R) Atom processors with support for Supplemental SSE 3 instructions.
      The resulting code may contain unconditional use of features that are not supported
      on other processors. This option also enables new optimizations in addition to
      Intel processor-specific optimizations including advanced data layout and code
      restructuring optimizations to improve memory accesses for Intel processors.</p>

      <p> Do not use this option if you are executing a program on a processor that
      is not an Intel processor. If you use this option on a non-compatible processor
      to compile the main program (in Fortran) or the function main() in C/C++, the
      program will display a fatal run-time error if they are executed on unsupported
      processors. </p>

   ]]>

</flag>

<flag name="f-Qparallel" class="optimization" regexp="[/-]Qparallel\b" parallel="yes">

    <![CDATA[       
      <p>Tells the auto-parallelizer to generate multithreaded code for loops that can be safely executed in parallel.
      To use this option, you must also specify option O2 or O3. The default numbers of threads spawned is equal to 
      the number of processors detected in the system where the binary is compiled. Can be changed by setting the 
      environment variable OMP_NUM_THREADS </p>
     
    ]]> 
  
</flag>

<flag name="f-Qscalar-rep" class="optimization" regexp="[/-]Qscalar-rep.">

    <![CDATA[       
      <p> This option enables scalar replacement performed during loop transformation. To use this option, you must also specify O3.
          -Qscalar-rep- disables this optimization.
            </p>
     
    ]]> 
  
</flag>

<flag name="f-Oa" class="optimization" regexp="[/-]Oa(?=\s|$)">

    <![CDATA[       
      <p>Tells the compiler to assume there is no aliasing.</p>
     
    ]]> 
  
</flag>


<flag name="f-Qprec-div-" class="optimization" regexp="[/-]Qprec-div-">
(disable/enable[default] -prec-div)
                
   <![CDATA[
      <p>-Qprec-div- enables optimizations that give slightly less precise results 
         than full IEEE division. </p>

      <p>When you specify -Qprec-div- along with some optimizations, such as 
         /QxT, the compiler may change floating-point division computations into 
         multiplication by the reciprocal of the denominator. 
         For example, A/B is computed as A * (1/B) to improve the speed of the 
         computation.</p>
      <p>However, sometimes the value produced by this transformation is 
         not as accurate as full IEEE division. When it is important to have fully 
         precise IEEE division, do not use -Qprec-div- which will enable the 
         default -Qprec-div and the result is more accurate, with some loss of 
         performance.</p>
   ]]> 

</flag>


<flag name="f-Qprof-gen" class="optimization" regexp="[/-]Qprof-gen(?=\s|$)">

   <![CDATA[
      <p>Instrument program for profiling for the first phase of
      two-phase profile guided otimization. This instrumentation gathers information
      about a program's execution paths and data values but does not gather
      information from hardware performance counters. The profile instrumentation
      also gathers data for optimizations which are unique to profile-feedback
      optimization.</p>
   ]]> 

</flag>

<flag name="f-Qprof-use" class="optimization" regexp="[/-]Qprof-use(?=\s|$)">

   <![CDATA[
      <p>Instructs the compiler to produce a profile-optimized 
      executable and merges available dynamic information (.dyn) 
      files into a pgopti.dpi file. If you perform multiple 
      executions of the instrumented program, -Qprof-use merges 
      the dynamic information files again and overwrites the 
      previous pgopti.dpi file.<br />
      Without any other options, the current directory is 
      searched for .dyn files</p>
   ]]> 
      
</flag>

<flag name="link_force_multiple1" class="optimization" regexp="\b\-Fe\$\@\-link(?=\s|$)">

   <![CDATA[
      <p>Enable SmartHeap and/or other library usage by forcing the linker to 
      ignore multiple definitions if present</p>
   ]]> 
 
</flag>

<flag name="f-no_wchar_t_keyword" class="portability" regexp="[/-]Qoption,cpp,--no_wchar_t_keyword(?=\s|$)">

<![CDATA[
 <p>-Qoption,<i>string</i>,<i>options</i>&nbsp;&nbsp;&nbsp; This option
            passes options to a specified tool.
         </p>
         <p><i>string</i>&nbsp;&nbsp;&nbsp; Is the name of the tool.<br/>
            Here: cpp indicates the C++ preprocessor.
         </p>
         <p><i>options</i>&nbsp;&nbsp;&nbsp; Are one or more comma-separated,
            valid options for the designated tool.<br/>
            Here: --no_wchar_t_keyword is passed to C++ preprocessor to provide
            the information that there is no wchar_t keyword.
         </p>
         <p>This flag must be used with Microsoft Visual Studio 2005.<br/>
            It avoids syntax errors coming from the use of wchar_t in 483.xalancbmk.
         </p>
]]> 

</flag>

<flag name="f-Qcxx_features" class="optimization" regexp="[/-]Qcxx-features(?=\s|$)">

   <![CDATA[
      <p>Enable C++ Exception Handling and RTTI<br />
      This option has the same effect as specifying /GX /GR.</p>
   ]]> 

<include flag="f-GX"/>
<include flag="f-GR"/>
 
</flag>

<flag name="f-GX" class="optimization" regexp="[/-]GX(?=\s|$)">
      This option enables C++ exception handling.    
</flag>

<flag name="f-GR" class="optimization" regexp="[/-]GR(?=\s|$)">
      Enables C++ Run Time Type Information (RTTI).    
</flag>


<flag name="set_stack_space" class="optimization" regexp="(?:/\S+/)?/F\d*">
      set the stack reserve amount specified to the linker 
</flag>

<flag name="set_stack_space_linker" class="optimization" regexp="[/-]stack[:=]\d+">
      set the stack reserve amount specified to the linker. Used after a /link toggle.
</flag>

<flag name="f-heap-arrays" class="optimization" regexp="[/-]heap-arrays">
      temporary arrays are allocated in heap memory
</flag>

<flag name="f-Qansi-alias" class="optimization" regexp="[/-]Qansi-alias(?=\s|$)">
      Enable/disable(DEFAULT) use of ANSI aliasing rules in
      optimizations; user asserts that the program adheres to
      these rules. 
</flag>

<flag name="f-Qprefetch" class="optimization" regexp="[/-]Qopt-prefetch(?=\s|$)">
      This option enables or disables prefetch insertion optimization. The goal of prefetching 
      is to reduce cache misses by providing hints to the processor about when data should be 
      loaded into the cache.
</flag>

<flag name="f-Qinline-calloc" class="optimization" regexp="[/-]Qinline-calloc(?=\s|$)">
      Directs the compiler to inline calloc() calls as malloc()/memset()
</flag>

<flag name="f-Qopt-streaming-stores" class="optimization" regexp="[/-]Qopt-streaming-stores[:=\s]+(?:always|auto|never)(?=\s|$)">
   <![CDATA[
      This option enables generation of streaming stores for optimization. This method stores data with 
      instructions that use a non-temporal buffer, which minimizes memory hierarchy pollution:
      <ul>
      <li>always - enables generation of streaming stores under the assumption that the application is memory bound</li>
      <li>auto   - compiler decides when streaming stores are used (DEFAULT)</li>
      <li>never  - disables generation of streaming stores</li>
      </ul>
   ]]>
</flag>

<flag name="f-Qvec-guard-write" class="optimization" regexp="[/-]Qvec-guard-write(?=\s|$)">
      Enables cache/bandwidth optimization for stores under conditionals (within vector loops)
      This option tells the compiler to perform a conditional check in a vectorized loop. 
      This checking avoids unnecessary stores and may improve performance by conserving bandwidth.
</flag>


<flag name="f-Qpar-runtime-control" class="optimization" parallel="yes" regexp="[/-]Qpar-runtime-control(?=\s|$)">
      Enable compiler to generate runtime control code for effective automatic parallelization.
      
      This option generates code to perform run-time checks for loops that have symbolic loop bounds. 
      If the granularity of a loop is greater than the parallelization threshold, the loop will be 
      executed in parallel. If you do not specify this option, the compiler may not parallelize loops 
      with symbolic loop bounds if the compile-time granularity estimation of a loop can not ensure 
      it is beneficial to parallelize the loop.
</flag>

<flag name="f-Qopt-ra-region-strategy" class="optimization" regexp="[/-]Qopt-ra-region-strategy[:=\s]+(?:routine|block|trace|loop|default)(?=\s|$)">
   <![CDATA[
      <p>Select the method that the register allocator uses to partition
      each routine into regions</p>
      <ul>
      <li>routine - one region per routine</li>
      <li>block - one region per block</li>
      <li>trace - one region per trace</li> 
      <li>loop - one region per loop</li>
      <li>default - compiler selects best option</li>
      </ul>
   ]]>
</flag>


<flag name="f-Qopt-multi-version-aggressive" class="optimization" regexp="[/-]Qopt-multi-version-aggressive(?=\s|$)">
      Multi-versioning is used for generating different versions of the loop based on  run time dependence testing,  
      alignment and checking for short/long trip counts.  If this option is turned on, it will trigger more versioning 
      at the expense of creating more overhead to check for pointer aliasing and scalar replacement.
</flag>

<flag name="f-Qunroll-aggressive" class="optimization" regexp="[/-]Qunroll-aggressive(?=\s|$)">
      Enables more aggressive unrolling heuristics
</flag>

<flag name="f-Qauto-ilp32" class="optimization" regexp="[/-]Qauto-ilp32">
   <![CDATA[
      <p> This option instructs the compiler to analyze and transform the program so that 64-bit pointers 
          are shrunk to 32-bit pointers wherever it is legal and safe to do so. In order for this option to 
          be effective the compiler must be able to optimize using the -Qipo option and must be able to 
          analyze all library/external calls the program makes.
      </p>
      <p> This option requires that the size of the program executable never exceed 2^32 bytes and all 
          data values can be represented within 32 bits. If the program can run correctly in a 32-bit system, 
          these requirements are implicitly satisfied. If the program violates these size restrictions, 
          unpredictable behavior might occur.
      </p>

   ]]> 
</flag>

<flag name="f-Qauto" class="optimization" regexp="[/-]Qauto">
   <![CDATA[
      <p>This option places local variables, except those declared as SAVE, to the run-time stack. 
      It is as if the variables were declared with the AUTOMATIC attribute. </p>

      <p> It does not affect variables that have the SAVE attribute or ALLOCATABLE attribute, 
      or variables that appear in an EQUIVALENCE statement or in a common block. </p>

      <p>This option may provide a performance gain for your program, but if your program depends on 
      variables having the same value as the last time the routine was invoked, your program may not 
      function properly. </p>

      <p> If you want to cause variables to be placed in static memory, specify /Qsave (Windows). </p>
   ]]> 
</flag>


<flag name="f-Oi-" class="optimization" regexp="[/-]Oi-">
      Disables inline expansion of all intrinsic functions. 
</flag>

<flag name="f-Op-" class="optimization" regexp="[/-]Op-(?=\s|$)">

   <![CDATA[
      <p>Disables conformance to the ANSI C and IEEE 754 standards for 
      floating-point arithmetic.</p>
   ]]> 
 
</flag>

<flag name="f-Oy" class="optimization" regexp="[/-]Oy(?=\s|$)">
      Allows use of EBP as a general-purpose register in optimizations.  
</flag>

<flag name="f-Os" class="optimization" regexp="[/-]Os(?=\s|$)">

   <![CDATA[
      <p>This option enables most speed optimizations, but disables some 
      that increase code size for a small speed benefit.</p>
   ]]> 
  
</flag>

<flag name="f-Og" class="optimization" regexp="[/-]Og(?=\s|$)">
      This option enables global optimizations.  
</flag>

<flag name="f-Ob_n" class="optimization" regexp="[/-]Ob(0|1|2)(?=\s|$)">

   <![CDATA[
      <p>Specifies the level of inline function expansion.</p>
         
         <p style="text-indent: -45px;margin-left: 45px">
         Ob0 - Disables inlining of user-defined functions. Note that 
               statement functions are always inlined.</p>
         <p style="text-indent: -45px;margin-left: 45px">
         Ob1 - Enables inlining when an inline keyword or an inline 
               attribute is specified. Also enables inlining according 
               to the C++ language.</p>
         <p style="text-indent: -45px;margin-left: 45px">
         Ob2 - Enables inlining of any function at the compiler's 
               discretion. </p>
   ]]> 
  
</flag>

<flag name="f-Gy" class="optimization" regexp="[/-]Gy(?=\s|$)">

   <![CDATA[
      <p>This option tells the compiler to separate functions into COMDATs 
      for the linker.</p>
   ]]> 
     
</flag>

<flag name="f-GF" class="optimization" regexp="[/-]GF(?=\s|$)">
      This option enables read only string-pooling optimization.   
</flag>

<flag name="f-Gf" class="optimization" regexp="[/-]Gf(?=\s|$)">
      This option enables read/write string-pooling optimization.    
</flag>

<flag name="f-Gs" class="optimization" regexp="[/-]Gs(?=\s|$)">

   <![CDATA[
      <p>This option disables stack-checking for routines with 4096 bytes 
      of local variables and compiler temporaries.</p>
   ]]> 
     
</flag>


<flag name="f-nostandard-realloc-lhs" class="optimization" regexp="[/-]nostandard-realloc-lhs(?=\s|$)">

   <![CDATA[
      <p>Explicitly sets assume keyword realloc_lhs to conform to the
      standard, or to override the default.</p>
   ]]> 
     
</flag>

<flag name="f-Qopenmp" class="optimization" parallel="yes" regexp="[/-]Qopenmp(?=\s|$)">

   <![CDATA[
      <p>Enable the compiler to generate multi-threaded code based on the
          OpenMP* directives</p>
   ]]> 
     
</flag>

<flag name="f-assume:byterecl" class="portability" regexp="[/-]assume[:=]byterecl(?=\s|$)">

   <![CDATA[
      <p>Specifies  that  the units for the OPEN statement RECL specifier (record length)
	value are in bytes for unformatted  data files,  not longwords (four-byte units).
	For formatted files, the RECL unit is always in  bytes.  The  default  is  -assume
        nobyterecl.</p>
   ]]> 
     
</flag>




</flagsdescription>

