<?xml version="1.0"?>
<!DOCTYPE flagsdescription
    SYSTEM "http://www.spec.org/dtd/cpuflags2.dtd"
>

<!-- ... You'll want a nice wide window when reading or editing this .................................................... -->

<!-- This flags file is a descendant of an example: $SPEC/Docs/flags-advanced.xml and is also used as the flags file for 
Oracle Solaris Studio SPEC CPU(R) submissions.  In order to serve as an example, there are more details in some of the comments 
than might otherwise be strictly necessary, and there are definitely more flags than are actually going to be used in the first 
submission.  --> 

<flagsdescription>

<filename>Oracle-Developer-Studio12.6</filename> 

<title>Oracle Solaris SPEC CPU(R) Flags</title>

<style>
<![CDATA[
ul { margin-top:.2em; }
table.lightborder        { border-style:solid; border-width:0px 0px 1px; border-color:#c0c0c0; }
td.lightborder           { vertical-align:top; padding:2px .3em 2px .2em; border-style:solid; border-width:1px 0px 0px 0px; border-color:#c0c0c0; }
th.lightborder           { vertical-align:top; text-align:left; font-family:monospace; font-weight:normal; padding:2px .3em 2px .2em;border-style:solid; border-width:1px 0px 0px 0px; border-color:#c0c0c0; }

]]>
</style>

<sw_environment>
<![CDATA[

<p><b><kbd>MTEXCLUSIVE</kbd></b> 
<br />If set to "Y", additional memory allocation buckets will be created, so that threads will not need to share buckets
unless more than 2*NCPUS threads are created.  This variable is used by mtmalloc.
</p>

<p><b><kbd>SUNW_MP_PROCBIND</kbd></b> 
<br />Binds threads in an OpenMP program to the virtual processors enumerated in the assignment.  Can also be set to TRUE,
which casues threads to be bound in a round-robin fashion.
</p>

<p><b><kbd>SUNW_MP_THR_IDLE</kbd></b> 
<br />Specifies whether idle threads should SLEEP or SPIN.
</p>

<p><b><kbd>STACKSIZE=&lt;n&gt;</kbd></b> 
<br /> Set the size of the stack (temporary storage area) for each slave thread of a multithreaded program.  </p>

<p><b><kbd>ulimit -s &lt;n&gt;</kbd></b> 
<br /> Sets the stack size to <kbd>n</kbd> kbytes, or "<kbd>unlimited</kbd>" to allow the stack size to grow without limit.
<br /> Note that the "heap" and the "stack" share space; if your application allocates large amounts of memory on the heap,
then you may find that the stack limit should not be set to "unlimited".  A commonly used setting for SPEC CPU purposes
is a stack size of 128MB (131072K). 
</p>
]]>
</sw_environment>

<header>
<![CDATA[

<table class="lightborder">
<tr>
   <th class="lightborder">Compilers</th>

   <td class="lightborder">
         <p style="margin: 0em 0em .1em 0em;">Oracle Developer Studio 12.6</p>
            <ul>
            <li>"<tt>cc</tt>": Oracle Developer Studio C</li>
            <li>"<tt>CC</tt>": Oracle Developer Studio C++</li>
            <li>"<tt>f95</tt>": Oracle Developer Studio Fortran</li>
            </ul>

      </td>
</tr>

<tr>
   <th class="lightborder">Operating&nbsp;systems: </th>
   <td class="lightborder">Solaris 10 and 11</td>
</tr>

<tr>
   <th class="lightborder">Copyright:</th>

   <td class="lightborder">
      <p style="margin-top:0em;">The text for many of the descriptions below was excerpted from the Oracle Developer Studio Compiler
      Documentation, which is copyright &copy; 2017 Oracle Corporation.  The original documentation can be found at <a
      href="http://docs.oracle.com/">http://docs.oracle.com/</a>.</p>
    </td>
</tr>

</table>

]]>
</header>


<!-- 
  ********************************************************************************************************************
  Compilers
  ********************************************************************************************************************* 
-->

<!-- If there is any chance that your compiler will be used by any third party in conjunction with another compiler, it is
   _strongly_ recommended that the flag names be chosen in such a way as to facilitate flag file merging.

  Sure, the C compiler name below could be "cc", but "oracle_studio_cc" is so much less ambiguous.

  The regexp below allows a path, as in /usr/opt/SUNwspro/.  The "(?:pattern)" notation groups the pattern inside the
  parentheses so that the "?" operator that immediately follows the closing parentheses applies to the pattern, thus allowing
  0 or 1 instances of the whole thing.  
-->

<flag name="compiler_path_eater"
      class="compiler"
      regexp="/\S+/(CC|cc|f90|f95)(?=\s|$)">
<example>/path/to/{CC|cc|f90|f95}</example>
This flag is just to trim the path from the compiler line.
<include text="$1" />
<display enable="0" />
</flag>


<flag name="mapfile_path_eater"
      class="compiler"
      regexp="-M\s+/\S+/(\S+)(?=\s|$)">
<example>/path/to/mapfile</example>
This flag is just to trim the path from a mapfile.
<include text="-M $1" />
<display enable="0" />
</flag>

<flag name="oracle_studio_CC"
      class="compiler"
      regexp="(?:/\S+/)?CC(?=\s|$)">
<example>CC</example>
Invoke the Oracle Developer Studio C++ Compiler
</flag>

<flag name="oracle_studio_cc"
      class="compiler"
      regexp="(?:/\S+/)?cc(?=\s|$)">
<example>cc</example>
Invoke the Oracle Developer Studio C Compiler.
</flag>


<flag name="oracle_studio_f90"
      class="compiler"
      regexp="(?:/\S+/)?f9[05]\b">
<example>f95</example>
Invoke the Oracle Developer Studio Fortran Compiler
</flag>




<!-- 
  ********************************************************************************************************************
  Compiler Component Splitters
  ********************************************************************************************************************* 
-->

<!-- 
  The Oracle Developer Studio compilation system allows comma-delimited flags to be sent to different components, as in
      -qoption iropt -Adata_access,-Mt7000,-Mm14000
  which sends 3 switches to the optimizer (iropt).

  The flags in this section are "splitters": they break up flags such as the above into their component parts.  If the above
  string were used with this flags file, the rule that follows would separate it into:

      -qoption iropt -Adata_access -qoption iropt -Mt7000 -qoption iropt -Mm14000 
  
  Commonly addressed components include cg, iropt, and f90comp.   

  In the regexp that follows, 
   $1   (cg|iropt|f90comp)   matches one of these three component names
   $2   (-[^,\s]+)           matches "-string"; to be more precise:
                                - matches itself
                                [^class] says match characters that are NOT described by the class between brackets
                                So, we'll accept anything but ",\s" which means comma or whitespace 
                                + says match one or more times
   $3   (-\S+)               matches "-" followed by one or more characters that are not whitespace
   $4   (?=\s|$)             matches whitespace or end of string (see flag-description.html section 3.3.4) 
--> 

<flag name="qoption_splitter" 
      class="optimization" 
      regexp="-[qQ]option (cg|iropt|f90comp) (-[^,\s]+),(-\S+)(?=\s|$)">
<example>Splitter rule for qoptions: -Qoption (cg|iropt|f90comp) -switch[,-switch...] </example>
<include text="-qoption $1 $2" />
<include text="-qoption $1 $3" />
<display enable="0" />
</flag>

<flag name="Wx_splitter" 
      class="optimization" 
      regexp="-W(2|c),(-[^,\s]+),(-\S+)(?=\s|$)">
<example>Splitter rule for Wx: -W2,-switch[,-switch...] or -Wc,-switch[,-switch...]</example>
<include text="-W$1,$2" />
<include text="-W$1,$3" />
<display enable="0" />
</flag>

<!-- 
  ********************************************************************************************************************
  Other Splitters
  ********************************************************************************************************************* 
-->

<!-- ********************************************************************************************************************
     The regexp below looks for a string of the form

          -qoption iropt -Ainline:<something>:<more stuff>

     It removes what it found, and puts back in its place

          -qoption iropt -Ainline:<something> -qoption iropt -Ainline:<more stuff>

     After multiple iterations through, the original macro flag will have been split into its components (which should all be
     described below).

     ********************************************************************* -->

<!-- -Ainline[:cp=n][:cs=n][:inc=n][:irs=n][:mi][:rs=n][:recursion=n] --> 
<flag name="Ainline_splitter"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Ainline:([^:\s]+):(\S+)(?=\s|$)">
<example>Splitter rule for -Ainline</example>
<include text="$1-Ainline:$2" />
<include text="$1-Ainline:$3" />
<display enable="0" />
</flag>

<!-- -Apf:llist=n:noinnerllist  -->
<flag name="Apf_splitter"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Apf:([^:\s]+):(\S+)(?=\s|$)">
<example>Splitter rule for -Apf</example>
<include text="$1-Apf:$2" />
<include text="$1-Apf:$3" />
<display enable="0" />
</flag>


<!-- -Qlp[=n][-av=n][-t=n][-fa=n][-fl=n][-ip=n] [-pt=weak][-ol=n] --> 
<flag name="Qlp_splitter1"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp(-|=)([^-\s]+)-(\S+)(?=\s|$)">
<example>Splitter rule for -Qlp</example>
<include text="$1-Qlp$2$3" />
<include text="$1-Qlp-$4" />
<display enable="0" />
</flag>

<!--
  *************************************************************************************************************************
  Flags

  Actual flag descriptions at last begin here.  The order is alphabetical by how the human reads it (so you might have to
  peek at that regexp to understand what it would look like to the human).  The alphabetizing is without regard to
  upper/lower case, without regard to the presence of leading punctuation, and without regard to the presence of a leading
  -Wx, or -qoption x

  Exception: The flag "-#" is alphabetized next to "-v".
  *************************************************************************************************************************
-->

<!-- Note that the name "F-Abcopy" allows a default <example> text of -Abcopy; see flag-description.html section 3.7 -->
<flag name="F-Abcopy"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Abcopy\b">
<![CDATA[
<p><small>[optimizer flag]</small></p>
<p>Increase the probability that the compiler will perform memcpy/memset transformations.</p>
]]>
</flag>

<!-- Note that the regular expression above might have been written slightly more efficiently.  These two would do similar
     things:

          regexp="(-W2,|-[qQ]option iropt )-Abcopy\b"
     or
          regexp="-(?:W2,|[qQ]option iropt )-Abcopy\b">

     The former notation captures into $1; the latter does not, and also factors out the common substring "-".  Therefore,
     the latter might be slightly more efficient.  But it is not used here because the former seems a little easier on the human
     eye.   You can read up about the ?: notation by typing "specperldoc perlre" and can make your own decision of whether to
     use it (TMTOWTDI).  -->

<flag name="abiopt_mangle"
   class="portability"
   regexp="(-W0,|-[qQ]option ccfe )-abiopt=mangle6\b">
     The mangle6 sub-option selects correct name mangling that might not be 
     compatible with prior compiler releases. 
</flag>


<flag name="Addint:ignore_parallel"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Addint:ignore_parallel\b">
<example>-Addint:ignore_parallel</example>
<![CDATA[
<p><small>[optimizer]</small></p>
<p>Ignore parallelization factors in loop interchange heuristics.</p>
]]>
</flag>

<flag name="Addint:sf"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Addint:sf=\d+\b">
<example>-Addint:sf=&lt;n&gt;</example>
<![CDATA[
<p><small>[optimizer]</small></p>
<p>When considering whether to interchange loops, set memory store operation weight to <kbd>n</kbd>.  A higher value of
<kbd>n</kbd> indicates a greater performance cost for stores.</p>
]]>
</flag>

<flag name="Afully:always"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Afully_unroll:always=on">
<example>-Afully_unroll:always=on</example>
<![CDATA[
<p><small>[optimizer]</small></p>
<p>Do aggressive loop fully unrolling based on the size and trip count of the loop.</p>
]]>
</flag>


<flag name="Ainline:cp"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Ainline:cp=\d+\b">
<example>-Ainline:cp=&lt;n&gt;</example>
<![CDATA[
<p><small>[optimizer flag]</small></p>
<p>Control the optimizer's loop inliner; set the minimum call site frequency counter in order to consider a routine for
inlining.  </p>
]]>
</flag>

<flag name="Ainline:cs"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Ainline:cs=\d+\b">
<example>-Ainline:cs=&lt;n&gt;</example>
<![CDATA[
<p><small>[optimizer flag]</small></p>
<p>Control the optimizer's loop inliner; Set inline callee size limit to <kbd>n</kbd>.  The unit roughly corresponds to the
number of instructions.  </p>
]]>
</flag>

<flag name="Ainline:inc"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Ainline:inc=\d+\b">
<example>-Ainline:inc=&lt;n&gt;</example>
<![CDATA[
<p><small>[optimizer flag]</small></p>
<p>Control the optimizer's loop inliner;
The inliner is allowed to increase the size of the program by up to <kbd>n</kbd>%.  </p>
]]>
</flag>

<flag name="Ainline:irs"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Ainline:irs=\d+\b">
<example>-Ainline:irs=&lt;n&gt;</example>
<![CDATA[
<p><small>[optimizer flag]</small></p>
<p>Control the optimizer's loop inliner; Allow routines to increase by up to <kbd>n</kbd>.  The unit roughly corresponds to
the number of instructions.  </p>
]]>
</flag>

<flag name="Ainline:mi"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Ainline:mi\b">
<example>-Ainline:mi</example>
<![CDATA[
<p><small>[optimizer flag]</small></p>
<p>Control the optimizer's loop inliner; Perform maximum inlining (without considering code size increase).  </p>
]]>
</flag>

<flag name="Ainline:recursion"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Ainline:recursion=1\b">
<example>-Ainline:recursion=1</example>
<![CDATA[
<p><small>[optimizer flag]</small></p>
<p>Control the optimizer's loop inliner; Allow routines that are called recursively to still be eligible for inlining.  </p>
]]>
</flag>

<flag name="Ainline:rs"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Ainline:rs=\d+\b">
<example>-Ainline:rs=400</example>
<![CDATA[
<p><small>[optimizer flag]</small></p>
<p>Inliner only considers routines smaller than n pseudo instructions as possible inline candidates.</p>
]]>
</flag>

<flag name="F-Aivsub3"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Aivsub3\b">
<![CDATA[
<p><small>[optimizer flag]</small></p>
<p>Increase the probability that loop induction variables will replaced, so that some extraneous code can be eliminated from
loops.</p>
]]>
</flag>

<flag name="Aloop_dist:ignore_parallel"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Aloop_dist:ignore_parallel\b">
<example>-Aloop_dist:ignore_parallel</example>
<![CDATA[
<p><small>[optimizer flag]</small></p>
<p> Ignore parallelization factors in loop distribution heuristics.  </p>
]]>
</flag>

<flag name="Amemopt:arrayloc"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Amemopt:arrayloc\b">
<example>-Amemopt:arrayloc</example>
<![CDATA[
<p><small>[optimizer flag]</small></p>
<p> Reconstruct array subscripts during memory allocation merging and data layout program transformation.  </p>
]]>
</flag>

<flag name="Aparallel:nthreads"
      class="optimization"  parallel="yes"
      regexp="(-W2,|-[qQ]option iropt )-Aparallel:nthreads=\d+\b">
<example>-Aparallel:nthreads=16</example>
<![CDATA[
<p>The option instructs the compiler on the number of threads to use for automatically parallelized regions. The nthreads
value is only applicable for parallelized regions in the modules that are compiled with this option. The value specified by
this option will override any values previously set by the OMP_NUM_THREADS or PARALLEL environment variable. The runtime
library may choose to alter the number of threads unless the environment variable OMP_DYNAMIC is set to false.</p>

<p>Note that this is a flag to the "iropt" component of the compilation system.  In general, flags may be sent to iropt using
"Qoption iropt" from the "f90" and "CC" commands; or using "-W2," from the "cc" command.</p>
]]>
</flag>
<flag name="Apf:llist"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Apf:llist=\d+\b">
<example>-Apf:llist=&lt;n&gt;</example>
<![CDATA[
<p><small>[optimizer flag]</small></p> 
<p> Do speculative prefetching for link-list data structures; perform prefetching <kbd>n</kbd> iterations ahead.  </p>
]]>
</flag>

<flag name="Apf:noinnerllist"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Apf:noinnerllist\b">
<example>-Apf:noinnerllist</example>
<![CDATA[
<p><small>[optimizer flag]</small></p> 
<p> Do speculative prefetching for link-list data structures; do not attempt prefetching for innermost loops.  </p>
]]>
</flag>

<flag name="Apf:pdl"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Apf:pdl=\d\b">
<example>-Apf:pdl=1</example>
<![CDATA[
<p><small>[optimizer flag]</small></p> 
<p>Allow prefetching through up to n levels of indirect memory references.</p>
]]>
</flag>

<flag name="array_pad_rows_n"
      class="optimization"
      regexp="(-[qQ]option f90comp )-array_pad_rows,\d+\b" compilers="oracle_studio_f90">
<example>-array_pad_rows,&lt;n&gt;</example>
<![CDATA[
<p> Enable padding of arrays by <kbd>n</kbd>.  </p>
]]>
</flag>

<flag name="Asac"
      class="optimization"
      regexp="(-W2,)-Asac">
<example>-W2,-Asac</example>
<![CDATA[
<p>
Structure Array Contraction reduces strides in a hot loop accessing a big array. This is done by collecting only the hot fields into a new structure and rearranging the dimensions in the new array (of the new structure) to minimize stride width, e.g. a[x][y] to a[y][x] 
</p>
]]>
</flag>

<flag name="F-Ashort_ldst"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Ashort_ldst\b">
<![CDATA[
<p><small>[optimizer flag]</small></p> 
<p> Convert multiple short memory operations into single long memory operations.  </p>
]]>
</flag>

<flag name="Atile:skewp"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Atile:skewp(?:b\d+)?\b">
<example>-Atile:skewp[:b&lt;n&gt;]</example>
<![CDATA[
<p><small>[optimizer flag]</small></p> 
<p> Perform loop tiling which is enabled by loop skewing.  Loop skewing is a transformation that transforms a non-fully
interchangeable loop nest to a fully interchangeable loop nest.  The optional <kbd>b&lt;n&gt;</kbd> sets the tiling block
size to <kbd>n</kbd>.  </p>
]]>
</flag>

<flag name="Aujam:inner:g"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Aujam:inner=g\b">
<example>-Aujam:inner=g</example>
<![CDATA[
<p><small>[optimizer flag]</small></p> 
<p> Increase the probability that small-trip-count inner loops will be fully unrolled.  </p>
]]>
</flag>

<flag name="F-crit"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-crit\b">
<![CDATA[
<p><small>[optimizer flag]</small></p> 
<p> Enable optimization of critical control paths </p>
]]>
</flag>

<!-- Here for the first time, we use "F-flagname" to allow both a default <example> and a defult regexp; see
flag-description.html sections 3.3.1 and 3.7 -->
<flag name="F-dalign"
      class="optimization">
Assume data is naturally aligned. 
</flag>

<flag name="Dalloca:__builtin_alloca"
      class="optimization">
<example>-Dalloca=__builtin_alloca</example>
Used for 403.gcc:  allow use of compiler's internal builtin alloca.
</flag>

<flag name="F-depend"
      class="optimization"
      compilers="oracle_studio_f90">
<include flag="F-xdepend" />
Synonym for -xdepend.
</flag>

<flag name="F-errfmt"
   class="other"
   compilers="oracle_studio_cc">
   Prepend the string "error:" to error messages, to make them easier to see.
</flag>

<flag name="D__MATHERR_ERRNO_DONTCARE"
      class="optimization"
      compilers="oracle_studio_cc,oracle_studio_CC">
<![CDATA[
<p> Allows the compiler to assume that your code does not rely on setting of the <tt>errno</tt> variable.  </p>
]]>
</flag>

<flag name="fast_CC"
      class="optimization"
      regexp="-fast\b" compilers="oracle_studio_CC">
<example>-fast</example>
A convenience option, this switch selects several other options that are described in this file.  
<include flag="D__MATHERR_ERRNO_DONTCARE" />
<include flag="F-fma:fused" />
<include flag="F-fns" />
<include flag="fsimple" flagtext="-fsimple=2" />
<include flag="ftrap_none" />
<include flag="xbuiltin_all" />
<include flag="F-xdepend" />
<include flag="F-xlibmil" />
<include flag="F-xlibmopt" />
<include flag="fxmemalign" flagtext="-xmemalign=8s" />
<include flag="xO" flagtext="-xO5" />
<include flag="xtarget" flagtext="-xtarget=native" />
</flag>

<flag name="fast_cc"
      class="optimization"
      regexp="-fast\b" compilers="oracle_studio_cc">
<example>-fast</example>
A convenience option, this switch selects several other options that are described in this file.  
<include flag="D__MATHERR_ERRNO_DONTCARE" />
<include flag="F-fma:fused" />
<include flag="F-fns" />
<include flag="fsimple" flagtext="-fsimple=2" />
<include flag="F-fsingle" />
<include flag="ftrap_none" />
<include flag="xalias_level_cc" flagtext="-xalias_level=basic" />
<include flag="xbuiltin_all" />
<include flag="F-xdepend" />
<include flag="F-xlibmil" />
<include flag="F-xlibmopt" />
<include flag="fxmemalign" flagtext="-xmemalign=8s" />
<include flag="xO" flagtext="-xO5" />
<include flag="xtarget" flagtext="-xtarget=native" />
</flag>

<flag name="fast_f90"
      class="optimization"
      regexp="-fast\b" compilers="oracle_studio_f90">
<example>-fast</example>
A convenience option, this switch selects the following switches that are described in this file:
<include flag="F-dalign" />
<include flag="F-depend" />
<include flag="F-fma:fused" />
<include flag="F-fns" />
<include flag="fsimple" flagtext="-fsimple=2" />
<include flag="F-ftrap_common" />
<include flag="F-xlibmil" />
<include flag="F-xlibmopt" />
<include flag="fxmemalign" flagtext="-xmemalign=8s" />
<include flag="xO" flagtext="-xO5" />
<include flag="F-xpad:local" />
<include flag="xtarget" flagtext="-xtarget=native" />
<include flag="xvector" flagtext="-xvector=lib" />
</flag>

<flag name="F-D_FILE_OFFSET_BITS:64" 
   class="portability">
   Ensure that there are no surprises if the benchmarks are run in an environment where file system metadata uses 64 bits.
</flag>

<flag name="features_cc"
      class="optimization"
      regexp="-features=(?:no%conststrings|conststrings|no%extensions|extensions|no%extinl|extinl|no%gcc_enums|gcc_enums|no%iddollar|iddollar|no%mergestrings|mergestrings|no%typeof|typeof|no%zla|zla|%none)\b"
      compilers="oracle_studio_cc">
<example>-features=no%extensions</example>
<![CDATA[
<p> The compiler's treatment of extern inline functions conforms by default to the behavior specified by the ISO/IEC 9899:1999 C standard. </p>
<ul>
   <li><b><kbd>conststrings</kbd></b> Enables the placement of string literals in readonly memory.</li>
   <li><b><kbd>no%conststrings</kbd></b> Disables the placement of string literals in readonly memory.</li>
   <li><b><kbd>extensions</kbd></b> Allows zero-sized struct/union declarations and void function with return statements returning a value to work.</li>
   <li><b><kbd>no%extensions</kbd></b> Disallows zero-sized struct/union declarations and void function with return statements returning a value to work.</li>
   <li><b><kbd>extinl</kbd></b> Generates extern inline functions as global functions.</li>
   <li><b><kbd>no%extinl</kbd></b> Generates extern inline functions as static functions.</li>
</ul>
]]>
</flag>

<flag name="features_CC"
      class="optimization"
      regexp="-features=(?:no%except|except|no%rtti|rtti)\b"
      compilers="oracle_studio_CC">
<example>-features=no%except</example>
<![CDATA[
<p> The compiler's treatment of extern inline functions conforms by default to the behavior specified by the ISO/IEC 9899:1999 C standard. </p>
<ul>
   <li><b><kbd>except</kbd></b> Allow C++ exceptions.</li>
   <li><b><kbd>no%except</kbd></b> Disallow C++ exceptions.</li>
   <li><b><kbd>rtti</kbd></b> Enable generation of RTTI (runtime type identification) data.</li>
   <li><b><kbd>no%rtti</kbd></b> Disallow generation of RTTI data.</li>
</ul>
]]>
</flag>

<flag name="F-fma:fused"
      class="optimization">
<![CDATA[
<p> Enables the use of the fused multiply-add instruction.</p>
]]>
</flag>



<flag name="F-fns"
      class="optimization">
Selects faster (but nonstandard) handling of floating point arithmetic exceptions and gradual underflow.
</flag>

<flag name="fsimple"
      class="optimization"
      regexp="-fsimple=\d+\b">
<example>-fsimple=&lt;n&gt;</example>
<![CDATA[
<p> Controls simplifying assumptions for floating point arithmetic: </p>
   <ul>
   <li><kbd>-fsimple=0</kbd> permits no simplifying assumptions.  Preserves strict IEEE 754 conformance.</li>
   
   <li><kbd>-fsimple=1</kbd> allows the optimizer to assume:
   <ul>
      <li>The IEEE 754 default rounding/trapping modes do not change after process initialization.</li>
      <li>Computations producing no visible result other than potential floating-point exceptions may be deleted.</li>
      <li>Computations with Infinity or NaNs as operands need not propagate NaNs to their results. For example, x*0 may be
      replaced by 0.</li>
      <li>Computations do not depend on sign of zero.</li>
   </ul></li>
   
   <li><kbd>-fsimple=2</kbd> permits more aggressive floating point optimizations that may cause programs to produce
   different numeric results due to changes in rounding. Even with <b><kbd>-fsimple=2</kbd></b>, the optimizer still is not
   permitted to introduce a floating point exception in a program that otherwise produces none.</li>
   </ul>
]]>
</flag>

<flag name="F-fsingle"
      class="optimization"
      compilers="oracle_studio_cc">
Evaluate float expressions as single precision.
</flag>

<flag name="F-ftrap_common"
      class="optimization">
Sets the IEEE 754 trapping mode to common exceptions (invalid, division by zero, and overflow).
</flag>

<flag name="ftrap_none"
      class="optimization"
      regexp="-ftrap=%none\b">
<example>-ftrap=%none</example>
Turns off all IEEE 754 trapping modes.
</flag>

<flag name="F-g"
      class="optimization"
      compilers="oracle_studio_cc,oracle_studio_f90,oracle_studio_CC">
Includes symbols in the executable.  If the optimization level is -xO3 or lower, some optimizations may be
disabled when -g is present.  At -xO4 or higher, full optimization is performed, even when -g is present.
</flag>

<flag name="F-g0"
      class="optimization"
      compilers="oracle_studio_CC">
Includes symbols in the executable.  If the optimization level is -xO3 or lower, some optimizations may be
disabled when -g0 is present.  At -xO4 or higher, full optimization is performed, even when -g0 is present.
</flag>

<flag name="F-g1"
      class="optimization"
      compilers="oracle_studio_cc,oracle_studio_f90,oracle_studio_CC">
Produce file and line number as well as simple parameter information  that  is  considered  crucial during post-mortem debugging.
</flag>

<flag name="include_file"
    class="portability"
    regexp="-include\s+(\S+)">
<example>-include alloca.h</example>
Include the designated file as if it were mentioned on the first line of the source file
in a #include preprocessor directive.
</flag>

<flag name="F-lbsdmalloc"
      class="optimization">
Links in a library of general purpose memory allocation routines which can be faster than those found in libc, at the expense
of more virtual memory consumed.
</flag>

<flag name="F-lcplxsupp" 
      class="portability">
This library is necessary to get full implementation of _Complex data types on Solaris 8 and Solaris 9.  It is not
necessary (and should not be used) on Solaris 10.
</flag>

<flag name="F-lfast"
      regexp="-lfast(_r)?"
      class="optimization">
This library provides faster versions of some common functions, such as malloc/free and bcopy.
</flag>

<flag name="libnostd"
      class="optimization"
      regexp="-library=no%Cstd">
Disables use of the compiler-provided Cstd header files. 
</flag>

<flag name="F-ll2amm"
      class="optimization">
Include a library containing chip-specific memory routines.  
</flag>

<flag name="F-lmopt"
      class="optimization">
Include the optimized math library.  This option usually generates faster code, but may produce slightly different
results.  Usually these results will differ only in the last bit. 
</flag>

<flag name="F-lmmheap"
      class="optimization">
Include the optimized heap memory managment library.  
</flag>

<flag name="F-lmtmalloc"
      class="optimization">
Include a library with malloc/free optimized for use in multithreaded applications.
</flag>

<flag name="F-lmvec"
      class="optimization">
Include a library with vectorized versions of some elementary mathematical functions.
</flag>

<flag name="F-lstdcxx4" 
      class="optimization"
      regexp="-library=stdcxx4">
Use the Apache stdcxx version 4 library that is installed as part of Oracle Solaris, instead of the default libCstd.
</flag>

<flag name="F-lstlport4" 
      class="optimization"
      regexp="-library=stlport4">
Use STLport's Standard Library implementation instead of the default libCstd.
</flag>

<flag name="F-lnostlport4" 
      class="optimization"
      regexp="-library=no%stlport4">
Disables use STLport's Standard Library implementation.
</flag>

<flag name="F-lsunmath" 
      class="optimization">
The libsunmath math library contains functions that are not specified by any standard but are useful in numerical software.
It also contains many of the functions that are in libm.so.2 but not in libm.so.1.
</flag>

<flag name="F-lumem"
      class="optimization">
Links in a library of "object caching" memory allocation routines which can be faster than those found in libc.
</flag>

<flag name="F-m32"
      class="optimization">
Specifies the ILP32 model: 32-bit ints, longs, and pointer types. 
</flag>

<flag name="F-m64"
      class="optimization">
Specifies the LP64 model: 32-bit ints, 64-bit longs and pointers types.
</flag>

<flag name="map.size.align"
      class="optimization"
      regexp="(-Wl,)?-M(,|\s+)map.(\d+)([KMG]).align">
Links in a linker mapfile that aligns text, data, and bss on $3 ${4}B boundaries.
</flag>

<flag name="map.bssalign"
      class="optimization"
      regexp="(-Wl,)?-M(,|\s+)(/usr/lib/ld/)?map.bssalign">
Links in a linker mapfile that enables the creation of a 'bss' segment, and aligns
the segment at 4MB.  This effectively provides an appropriate alignment for
large page mapping of the heap.
</flag>

<flag name="F-noex"
      class="optimization"
      compilers="oracle_studio_CC">
Do not allow C++ exceptions.  A throw specification on a function is accepted but ignored; the compiler does not generate
exception code.  
</flag>

<flag name="F-O"
      class="optimization">
<include flag="xO" flagtext="-xO3" />
A synomym for -xO3.
</flag>

<flag name="pad"
      class="optimization"
      regexp="-pad=">
Do not allow C++ exceptions.  A throw specification on a function is accepted but ignored; the compiler does not generate
exception code.  
</flag>

<flag name="Qdepgraph-early_cross_call"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qdepgraph-early_cross_call=1\b">
<example>-Qdepgraph-early_cross_call=1</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> There are several scheduling passes in the compiler.  This option allows early passes to move instructions across call
instructions.  </p>
]]>
</flag>

<flag name="Qeps:do_spec_load"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qeps:do_spec_load=1\b">
<example>-Qeps:do_spec_load=1</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Allow the enhanced pipeline scheduler (EPS) to use speculative (non-faulting) loads.  </p>
]]>
</flag>

<flag name="Qeps:enabled"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qeps:enabled=1\b">
<example>-Qeps:enabled=1</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Use enhanced pipeline scheduling (EPS) and selective scheduling algorithms for instruction scheduling.  </p>
]]>
</flag>

<flag name="Qeps:rp_filtering_margin"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qeps:rp_filtering_margin=\d+\b">
<example>-Qeps:rp_filtering_margin=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> The number of live variables allowed at any given point is n more than the number of physical registers. Setting n to a
significantly large number (e.g., 100) will disable register pressure heuristics in EPS.  </p>
]]>
</flag>

<flag name="Qeps:ws"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qeps:ws=\d+\b">
<example>-Qeps:ws=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Set the EPS window size, that is, the number of instructions it will consider across all paths when trying to find
independent instructions to schedule a parallel group.  Larger values may result in better run time, at the cost of increased
compile time.  </p>
]]>
</flag>

<flag name="Qgsched-T"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qgsched-T=[456]\b">
<example>-Qgsched-T=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Sets the aggressiveness of the trace formation, where <kbd>n</kbd> is 4, 5, or 6.  The higher the value of <kbd>n</kbd>,
the lower the branch probability needed to include a basic block in a trace.  </p>
]]>
</flag>

<flag name="Qgsched-trace_late"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qgsched-trace_late=1\b">
<example>-Qgsched-trace_late=1</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Enable the (late) trace scheduler. This is a new feature of the compiler which is being tuned from release to release.
It may become the default in a future release.  </p>
]]>
</flag>

<flag name="Qgsched-trace_spec_load"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qgsched-trace_spec_load=1\b">
<example>-Qgsched-trace_spec_load=1</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> When performing trace scheduling, enable the conversion of loads to non-faulting loads inside the trace.  </p>
]]>
</flag>

<flag name="Qicache-chbab"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qicache-chbab=1\b">
<example>-Qicache-chbab=1</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Turn on optimization to reduce branch after branch penalty: nops will be inserted to prevent one branch from occupying
the delay slot of another branch.  </p>
]]>
</flag>

<flag name="Qipa:valueprediction"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qipa:valueprediction\b">
<example>-Qipa:valueprediction</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Use profile feedback data to predict values and attempt to generate faster code along these control paths, even at the
expense of possibly slower code along paths leading to different values. Correct code is generated for all paths.  </p>
]]>
</flag>

<flag name="Qiselect-funcalign"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qiselect-funcalign=\d+\b">
<example>-Qiselect-funcalign=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Do function entry alignment at <kbd>n</kbd>-byte boundaries.  </p>
]]>
</flag>

<flag name="Qiselect-rcpa"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qiselect-rcpa=\d+\b">
<example>-Qiselect-rcpa=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Single- and double-precision floating-point division operations are approximated based on the SPARC64 X reciprocal
approximation instructions (frcpa[sd]).
This option has no effect unless -xarch=sparcace or -xarch=sparcaceplus, and -fsimple=2 are both in effect.
In this situation, the use of -fns=yes is strongly advised.
These approximated floating-point division operations do not conform to IEEE-754.
Furthermore, spurious floating-point exceptions can be raised in certain corner cases. In particular, the invalid
operation exception is raised when the divisor is subnormal or an infinity, or when the dividend is an infinity and
the divisor is near the overflow threshold (i.e. with magnitude greater than 2^126 or 2^1022 in single- or double-precision
respectively).
</p>
]]>
</flag>

<flag name="Qiselect-rsqrta"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qiselect-rsqrta=\d+\b">
<example>-Qiselect-rsqrta=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Single- and double-precision floating-point square root operations are approximated based on the SPARC64 X approximation instructions
(frsqrta[sd]).
This option has no effect unless -xarch=sparcace or -xarch=sparcaceplus, and -fsimple=2 are both in effect. In this situation, 
the use of -fns=yes is strongly advised.
These approximated floating-point square root operations do not conform to IEEE-754.
</p>
]]>
</flag>

<flag name="Qiselect-rsqrta1x"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qiselect-rsqrta1x=\d+\b">
<example>-Qiselect-rsqrta1x=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> The reciprocal of single- and double-precision floating-point square root operations are approximated based on the SPARC64 X approximation
instructions (frsqrta[sd]).
This option has no effect unless -xarch=sparcace or -xarch=sparcaceplus, and -fsimple=2 are both in effect. In this situation,
the use of -fns=yes is strongly advised.
Furthermore, DZ exception is never raised when input is a positive subnormal or a zero, and a positive zero is returned instead of infinity with appropriate sign.
</p>
]]>
</flag>

<flag name="Qiselect-sw_pf_tbl_th"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qiselect-sw_pf_tbl_th=\d+\b">
<example>-Qiselect-sw_pf_tbl_th=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Peels the most frequent test branches/cases off a switch until the branch probability reaches less than 1/n. This is
effective only when profile feedback is used </p>
]]>
</flag>

<flag name="Qlp"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp=\d+(?=\s|$)">
<example>-Qlp=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Control irregular loop prefetching; turns the module on (1) or off (0) (default is on for F90/F95; for C/C++ the default is
off unless -xprefetch=auto or -xprefetch_level=[2|3] is present, in which case the default is on) </p>
]]>
</flag>

<flag name="Qlp-av"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp-av=\d+(?=\s|$)">
<example>-Qlp-av=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Control irregular loop prefetching; sets the prefetch look ahead distance, in bytes.  The default is 256.  </p>
]]>
</flag>

<flag name="Qlp-fa"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp-fa=\d+(?=\s|$)">
<example>-Qlp-fa=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Control irregular loop prefetching; a setting of "1" means force user settings to override internally computed values.</p>
]]>
</flag>

<flag name="Qlp-fl"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp-fl=\d+(?=\s|$)">
<example>-Qlp-fl=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Control irregular loop prefetching; a setting of "1" means force the optimization to be turned on for all languages.</p>
]]>
</flag>

<flag name="Qlp-imb"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp-imb=1(?=\s|$)">
<example>-Qlp-imb=1</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Insert indirect prefetches when the indirect access chain spans across basic blocks.</p>
]]>
</flag>

<flag name="Qlp-it"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp-it=\d(?=\s|$)">
<example>-Qlp-it=3</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Indicates to the compiler to insert n extra prefetches for each indirect access in outer loops</p>
]]>
</flag>

<flag name="Qlp-ol"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp-ol=1(?=\s|$)">
<example>-Qlp-ol=1</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Turns on prefetching for outer loops</p>
]]>
</flag>

<flag name="Qlp-prt"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp-prt=1(?=\s|$)">
<example>-Qlp-prt=1</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Use prefetch with function code 1 (prefetch for one read) for memory accesses  which are read only. </p>
]]>
</flag>

<flag name="Qlp-prwt"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp-prwt=3(?=\s|$)">
<example>-Qlp-prwt=3</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Use prefetch with function code 3 (prefetch for one write) for memory accesses which are read and then written.</p>
]]>
</flag>

<flag name="Qlp-pt_weak"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp-pt=weak(?=\s|$)">
<example>-Qlp-pt=weak</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Control irregular loop prefetching; use weak prefetches in the general loop prefetch.  </p>
]]>
</flag>

<flag name="Qlp-pwt"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp-pwt=3(?=\s|$)">
<example>-Qlp-pwt=3</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Use prefetch with function code 3 (prefetch for one write) for memory accesses which are written only. </p>
]]>
</flag>

<flag name="Qlp-t"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlp-t=\d+(?=\s|$)">
<example>-Qlp-t=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Control irregular loop prefetching; sets the number of attempts at prefetching.  If not specified, <kbd>t=2</kbd> if
<kbd>-xprefetch_level=3</kbd> has been set; otherwise, defaults to <kbd>t=1</kbd>.  </p>
]]>
</flag>


<flag name="Qluen"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qlu-en=1-t=4\b">
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Enable the loop unroller (en=1 enables, en=0 disables) for loops with control flow, with an unroll count of 4.</p>
]]>
</flag>

<!-- In this flag, the '+' in the regexp is escaped with a backslash, because '+' is a special character.  Without that
backslash, this rule would match "-Qms_pipealldoall" or "-Qms_pipeeeeeeeeeeeeeealldoall", but NOT "-Qms_pipe+alldoall".  
-->


<flag name="Qms_pipe_alldoall"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qms_pipe\+alldoall\b">
<example>-Qms_pipe+alldoall</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Specifies that all loops can be pipelined without needing to be concerned about loop-carried dependencies.  </p>
]]>
</flag>

<flag name="Qms_pipe_intdivusefp"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qms_pipe\+intdivusefp\b">
<example>-Qms_pipe+intdivusefp</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> In pipelined loops, use floating point divide instructions for signed integer division.  </p>
]]>
</flag>

<flag name="Qms_pipe_pref"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qms_pipe-pref\b">
<example>-Qms_pipe-pref</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Disable prefetching within modulo scheduling (used in software pipelining).</p>
]]>
</flag>

<flag name="Qms_pipe_prefolim"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qms_pipe[-+]prefolim=\d+\b">
<example>-Qms_pipe+prefolim=&lt;n&gt;</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Set number of outstanding prefetches in pipelined loops to &lt;n&gt; </p>
]]>
</flag>

<flag name="Qms_pipe-pref_prolog" 
      class="optimization" 
      regexp="(-Wc,|-[qQ]option cg )-Qms_pipe-pref_prolog\b">
<example>-Qms_pipe-pref_prolog</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Turn off prefetching in the prolog of modulo scheduled loops.  </p>
]]>
</flag>

<flag name="Qms_pipe-prefst" 
      class="optimization" 
      regexp="(-Wc,|-[qQ]option cg )-Qms_pipe-prefst\b">
<example>-Qms_pipe-prefst</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Turn off prefetching for stores in the pipeliner.  </p>
]]>
</flag>

<flag name="Qms_pipe-prefstrong_0" 
      class="optimization" 
      regexp="(-Wc,|-[qQ]option cg )-Qms_pipe-prefstrong=0\b">
<example>-Qms_pipe-prefstrong=0</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Turn off the use of strong prefetches in modulo scheduled loops.  </p>
]]>
</flag>

<flag name="Qms_pipe_ulms"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qms_pipe\+ulmscc=1\b">
<example>-Qms_pipe+ulms=1</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>Allow the pipeliner to unroll multi-instruction loops that set integer condition codes</p> 
]]>
</flag>

<flag name="Qms_pipe_unoovf"
      class="optimization"
      regexp="(-Wc,|-[qQ]option cg )-Qms_pipe\+unoovf\b">
<example>-Qms_pipe+unoovf</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Assert (to the pipeliner) that unsigned int computations will not overflow.  </p>
]]>
</flag>

<flag name="Qpeep-Sh0" 
      class="optimization" 
      regexp="(-Wc,|-[qQ]option cg )-Qpeep-Sh0\b">
<example>-Qpeep-Sh0</example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p> Reduce the probability that the compiler will hoist sethi insructions out of loops.  </p>
]]>
</flag>


<flag name="Qpeep-Ex-cmov" 
      class="optimization" 
      regexp="(-Wc,|-[qQ]option cg )-Qpeep-Ex1?:minmax_use_cmov=2\b">
      <example>-Qpeep-Ex[1]:minmax_use_cmov=2 </example>
<![CDATA[
<p><small>[code generator flag]</small></p>
<p>During Expansion (that is, prior to register allocation), use the 'movcc' instruction to implement min and max operations.  The options for use of movcc include: </p>
<ul>
   <li>0 to disable</li> 
   <li>1 to let the compiler choose, and</li> 
   <li>2 to enable.</li>
</ul>
<p> If the "Ex" is followed by the optional character "1", then movcc will be applied during the first phase of peephole optimization, but not during later phases.</p>
]]>
</flag>


<flag name="Rloop_dist"
      class="optimization" 
      regexp="(-W2,|-[qQ]option iropt )-Rloop_dist">
Do not perform loop distribution transformations.
</flag>

<flag name="Rujam"
      class="optimization"
      regexp="(-W2,|-[qQ]option iropt )-Rujam\b">
<example>-Rujam</example>
<![CDATA[
<p><small>[optimizer flag]</small></p> 
<p>Disable loop unroll and jam optimization in iropt</p>
]]>
</flag>

<flag name="F-stackvar" 
      class="optimization" 
      compilers="oracle_studio_f90">
Allocate routine local variables on the stack.
</flag>

<flag name="staticlib"
   class="optimization" 
   regexp="-staticlib=\S+\b"
   compilers="oracle_studio_CC">
   <example>-staticlib=%all</example>
   Link with static libraries.  When the value "%all" is chosen, then all available static libraries are used.  Note that the set of libraries may change from release to release, and that many libraries are available only in dynamic form.
</flag>

<flag name="stdc"
   class="optimization"
   compilers="oracle_studio_cc"
   regexp="-std=c\d+\b">
   <example>-std=c99, -std=c11</example>
   Selects the C language dialect.  
</flag>

<flag name="stdcxx"
   class="optimization"
   compilers="oracle_studio_CC"
   regexp="-std=(c\+\+\d\d|sun03)\b">
   <example>-std=c++03, -std=sun03, -std=c++11</example>
   Selects the C++ language dialect.  
</flag>

<flag name="template_CC" 
      class="optimization"
      regexp="-template=\S+\b">
   <example>-template=extdef</example>
<![CDATA[
<p>Controls various template options:</p>
<dl>
<dt>[no%]extdef</dt>
<dd>[Do not] Search for template definitions in separate source files. With no
%extdef, the compiler predefines _TEMPLATE_NO_EXTDEF</dd> 
<dt>[no%]geninlinefuncs</dt>
<dd>[Do not] Generate unreferenced inline member functions for explicitly
instantiated class templates. </dd>
<dt>[no%]wholeclass</dt>
<dd>[Do not] Instantiate a whole template class, rather than only those functions
that are used. You must reference at least one member of the class.
Otherwise, the compiler does not instantiate any members for the
class. </dd>
</dl>
<p>The default is <tt>-template=no%wholeclass,no%extdef</tt>.</p>
]]>
</flag>

<flag name="verbose_cc" 
      class="other" 
      regexp="-#(?=\s|$)" compilers="oracle_studio_cc">
<example>-#</example>
Turns on verbose mode, showing how command options expand. Shows each component as it is invoked.  
</flag>

<flag name="verbose_CC" 
      class="other" 
      regexp="-verbose=\S+\b">
<example>-verbose=diags,version</example>
<![CDATA[
<p>Controls compiler verbosity.  There are several values that can be used with this flag:</p>
<dl>
<dt>[no%]diags</dt>
<dd>[Do not] Print the command line for each compilation pass</dd> <dt>[no%]template</dt>
<dd>[Do not] Turn on the template instantiation <tt>verbose</tt> mode (sometimes called the "verify" mode). The 
<tt>verbose</tt> mode displays each phase of instantiation as it occurs during compilation.</dd>
<dt>[no%]version</dt>
<dd>[Do not] Direct the CC driver to print the names and version numbers of the programs it invokes.</dd>
<dt>%all</dt>
<dd>Invokes all of the above.</dd>
<dt>%none</dt>
<dd><tt>-verbose=%none</tt> is the same as <tt>-verbose=no%template,no%diags,no%version</tt>.</dd>
</dl>
<p>The default is <tt>-verbose=%none</tt>.</p>
]]>
</flag>

<flag name="verbose_diags_CC" 
      class="other" 
      regexp="-v\b" compilers="oracle_studio_CC">
<example>-v</example>
<![CDATA[
<p>Same as <tt>-verbose=diags</tt>.</p>
]]>
<include flag="verbose_CC" flagtext="-verbose=diags" /> 
</flag>

<flag name="verbose_f90" 
      class="other" 
      regexp="-v\b" compilers="oracle_studio_f90">
<example>-v</example>
This flag will cause the Oracle Developer Studio Fortran compiler to emit verbose messages.  
</flag>


<flag name="version_ccf90" 
      class="other" 
      regexp="-V\b" compilers="oracle_studio_cc,oracle_studio_f90">
<example>-V</example>
Directs the compiler to print the name and version ID of each component as the compiler executes.  
</flag>

<flag name="version_CC" 
      class="other" 
      regexp="-V\b" compilers="oracle_studio_CC">
<example>-V</example>
<![CDATA[
<p>Same as <tt>-verbose=version</tt>.</p>
]]>
<include flag="verbose_CC" flagtext="-verbose=version" /> 
</flag>

<flag name="X"
      class="optimization" 
      regexp="-X(a|c)"
      compilers="oracle_studio_cc">
<example>-X[a|c]</example>
<![CDATA[
<p>Specifies the degree of conformance with the ISO C standard: -Xc indicates strict conformance, whereas -Xa indicates ISO C
plus some K&amp;R compatibility extensions.</p>
]]>
</flag>


<flag name="xalias_level_cc" 
      class="optimization" 
      regexp="-xalias_level=(?:any|basic|weak|layout|strict|std|strong)\b"
      compilers="oracle_studio_cc">
<example>-xalias_level=[any|basic|weak|layout|strict|std|strong]</example>
<![CDATA[
<p> Allows the compiler to perform type-based alias analysis at the specified alias level: </p>
<ul>
   <li><b><kbd>any</kbd></b> assume all references can alias each other</li>
   <li><b><kbd>basic</kbd></b> assume that memory references that involve different C basic types do not alias each
      other.</li> 
   <li><b><kbd>weak</kbd></b> assume that any structure pointer an point to any structure type</li> 
   <li><b><kbd>layout</kbd></b> assume that memory references with the same sequence of types can alias</li>
   <li><b><kbd>strict</kbd></b> assume that structs and unions do not alias if their types differ, after removing tags.</li>
   <li><b><kbd>std</kbd></b> assume aliasing rules described in the ISO 1999 C standard: structs and unions must have the
      same types and tags in order to alias.</li>
   <li><b><kbd>strong</kbd></b> in addition to the restrictions at the <kbd>std</kbd> level, assume that pointers of type
   <kbd>char *</kbd> are used only to access an object of type char; and assume that there are no interior pointers.</li>
</ul>
]]>
</flag>

<flag name="xalias_level_CC" 
      class="optimization" 
      regexp="-xalias_level=(?:any|simple|compatible)?\b" 
      compilers="oracle_studio_CC">
<example>-xalias_level[=any|simple|compatible]</example>
<![CDATA[
<p>Allows the compiler to perform type-based alias analysis:</p>
<ul>
  <li><b><kbd>any</kbd></b> assumes that any type can alias any other</li>
  <li><b><kbd>simple</kbd></b> assumes that fundamental types are not aliased</li>
  <li><b><kbd>compatible</kbd></b> assumes that layout-incompatible types are not aliased.</li>
</ul>
]]>
</flag>


<flag name="xarch" 
      class="optimization" 
      regexp="-xarch=(?:v8plusa|v8plusb|generic|native|ultra3cu|sparcfmaf|sparcima|sparcvis2|sparcvis3|sparc5)\b">
<example>-xarch=...</example>
<![CDATA[
<p> Specifies which instructions can be used.  Among the choices are:</p>
<ul>
   <li><kbd><b>native</b></kbd> Use the instructions available on the current processor</li>
   <li><kbd><b>generic</b></kbd> Use instructions that are compatible with most SPARC processors</li>
   <li><kbd><b>ultra3cu</b></kbd> Use instructions compatible with the UltraSPARC IIIcu processor</li>
   <li><kbd><b>v8plusa</b></kbd> Use instructions that are available on the UltraSPARC processors</li>
   <li><kbd><b>v8plusb</b></kbd> Use instructions that are available on the UltraSPARC III/IV processors</li>
   <li><kbd><b>sparcfmaf</b></kbd> Allows use of the v8plusb set plus extensions for floating-point multiply-add</li> 
   <li><kbd><b>sparcima</b></kbd> Allows use of the v8plusb set plus extensions for floating-point and integer multiply-add</li>
   <li><kbd><b>sparcvis2</b></kbd> Use instructions that are available on the UltraSPARC III/IV processors</li>
   <li><kbd><b>sparcvis3</b></kbd> Use instructions that are available with sparcvis2 as well as fused multiply-add and VIS version 3.0 instrutions.</li>
   <li><kbd><b>sparc5</b></kbd> Use instructions compatible with the SPARC M7 processor</li>
</ul>
]]>
</flag>

<flag name="F-xautopar" 
      class="optimization"
      parallel="yes" >
Turn on automatic parallelization for multiple processors.
</flag>

<flag name="xbuiltin_all" 
      class="optimization" 
      regexp="-xbuiltin=%all\b"> 
<example>-xbuiltin=%all</example>
Substitute intrinsic functions or inline system functions where profitable for performance.
</flag>

<flag name="xcache" 
      class="optimization" 
      regexp="-xcache=(generic|native|\d+(/\d+){2,3}(\:\d+(/\d+){2,3}){0,2})\b"> 
<example>-xcache=...</example>
<![CDATA[
<p>xcache defines the cache properties for use by the optimizer.  It can specify
use of default assumptions ("generic"); use of whatever the compiler can assume
about the current platform ("native"); or an explicit description of up to three 
levels of cache, using colon-separated specifiers of the form <tt>si/li/ai[/ti]</tt>, 
where:</p>
<ul>
<li><tt>si</tt> is the size of the cache, in kb</li>
<li><tt>li</tt> is the line size, in bytes</li>
<li><tt>ai</tt> is the associativity</li>
<li><tt>ti</tt> (optional) is the number of hardware threads share the cache </li>
</ul>
]]>
</flag>

<flag name="F-xchar:u"
   class="portability" >
   Treat character constants and variables declared as 'char' as unsigned.
</flag>


<flag name="xcheck"
      class="optimization"
      regexp="-xcheck=%none">
<example>-xcheck=%none</example>
Do not perform any of the runtime check for stack overflow of the main thread in a singly-threaded program as well as slave-thread stacks in a multi-threaded program.
</flag>

<flag name="xchip" 
      class="optimization" 
      regexp="-xchip=(?:native|generic|sparc64viiplus|sparc64x|sparc64xplus|sparc64xii|ultraT2plus|T4|T5|T7|M5|M6|M7)\b">
<example>-xchip=...</example>
<![CDATA[
<p> xchip determines timing properties that are assumed by the compiler.  It does not limit which instructions are allowed
(see xtarget for that).  Among the choices are:</p>
<ul>
   <li><kbd><b>native</b></kbd> Optimize for the current processor</li>
   <li><kbd><b>generic</b></kbd> Use timing properties for good performance on most SPARC processors</li>
   <li><kbd><b>sparc64viiplus</b></kbd> Optimize for the SPARC64 VII+ processor</li>
   <li><kbd><b>sparc64x</b></kbd> Optimize for the SPARC64 X processor</li>
   <li><kbd><b>sparc64xplus</b></kbd> Optimize for the SPARC64 X+ processor</li>
   <li><kbd><b>sparc64xii</b></kbd> Optimize for the SPARC64 XII processor</li>
   <li><kbd><b>T4</b></kbd> Optimize for the SPARC T4 processor</li>
   <li><kbd><b>T5</b></kbd> Optimize for the SPARC T5 processor</li>
   <li><kbd><b>M5</b></kbd> Optimize for the SPARC M5 processor</li>
   <li><kbd><b>M7</b></kbd> Optimize for the SPARC M7 processor</li>
</ul>
]]>
</flag>



<flag name="F-xdepend" 
      class="optimization" >
Analyze loops for inter-iteration data dependencies, and do loop restructuring. 
Loop restructuring includes loop interchange, loop fusion, 
  scalar replacement, and elimination of "dead" array assignments.
</flag>

<flag name="xfilebyte"
      class="portability"
      regexp="-xfilebyteorder=big8:%all">
      Declares that all files (other than scratch files) should be interpreted as big-endian with 8-btye alignment.
</flag>

<flag name="xheap_report"
      class="other"
      regexp="(-W2,|-[qQ]option iropt )-xheap_report">
Report memory used by the optimizer.
</flag>

<flag name="xinline_" 
      class="optimization" 
      regexp="-xinline=(?=\s|$)">
<example>-xinline=</example>
Turn off inlining.
</flag>

<flag name="xinline_param"
      class="optimization"
      regexp="-xinline_param=(level?:\d|max_inst_hard:\d+,max_inst_soft:\d+,max_growth:\d+|max_growth:\d+)">
<example>-xinline_param=lavel:2</example>
<![CDATA[
<p> Use  this option to manually change the heuristics used by the compiler for deciding when to inline a function call.  </p>
<ul>
<li><kbd>level:1</kbd> enables automatic generation of basic inlining.</li>
<li><kbd>level:2</kbd> enables automatic generation of medium inlining.</li>
<li><kbd>level:3</kbd> enables automatic generation of aggressive inlining.</li>
<li><kbd>max_inst_hard:1000</kbd> enables automatic generation of inlining only considers functions smaller than 1000 pseudo instructions.</li>
<li><kbd>max_inst_soft:500</kbd> enables automatic generation of inlining whose size limit to 500 pseudo instructions.</li>
<li><kbd>max_growth:60</kbd> enables automatic generation of inlining whose size limit to 60% of the program.</li>
</ul>
]]>
</flag>

<flag name="xipo" 
      class="optimization" 
      regexp="-xipo(?:=\d+)\b">
<example>-xipo or -xipo=(0|1|2)</example>
<![CDATA[
<p> Perform optimizations across all object files in the link step: </p>
<ul>
<li><kbd>0</kbd> = off</li>
<li><kbd>1</kbd> = on</li>
<li><kbd>2</kbd> = performs whole-program detection and analysis.</li>
</ul>
<p>At -xipo=2, the compiler performs inter-procedural aliasing analysis as well as optimization of memory allocation and
layout to improve cache performance.  </p>
]]>
</flag>

<flag name="xjobs"
      class="other"
      regexp="-xjobs=\d+\b">
<example>-xjobs=&lt;n&gt;</example>
<![CDATA[
<p>Specify the <tt>-xjobs</tt> option to set how many processes the compiler creates to complete its work. Currently,
<tt>-xjobs</tt> works only with the <tt>-xipo</tt> option. When you specify <tt>-xjobs=</tt><i>n</i>, the interprocedural
optimizer uses <i>n</i> as the maximum number of code generator instances it can invoke to compile different files.
</p>
]]>
</flag>

<flag name="F-xlibmil" 
      class="optimization" >
Use inline expansion for math library, libm.
</flag>

<flag name="F-xlibmopt" 
      class="optimization"> 
Select the optimized math library.
</flag>


<flag name="F-xlinkopt" 
      class="optimization" >
<![CDATA[
<p>Perform link-time optimizations on the resulting executable over and above any
optimizations in the object files. These optimizations are performed at link time by analyzing the object binary code.  The
meanings of the options are:</p>

<ul>
<li><p> <b>0.</b> The link optimizer is disabled. (This is the default.) </p></li>

<li><p> <b>1.</b> Perform optimizations based on control flow analysis, including instruction cache coloring and branch optimizations, at link
time. </p></li>

<li><p> <b>2.</b> Perform additional data flow analysis, including dead-code elimination and address computation simplification, at
link time. </p></li>
</ul>

]]>
</flag>


<flag name="fxmemalign"
      class="optimization"
      regexp="-xmemalign=\d+s\b">
<example>-xmemalign=&lt;n&gt;s</example>
<![CDATA[
<p> Sets the maximum assumed data alignment: </p>
   <ul>
   <li><kbd>-xmemalign=4s</kbd> assumes a 4 byte boundary and raise 
    signal SIGBUS in the case of misaligned data accesses.
   </li>
   <li><kbd>-xmemalign=8s</kbd> assumes a 8 byte boundary and raise 
    signal SIGBUS in the case of misaligned data accesses.
   </li>
   </ul>
]]>
</flag>

<flag name="xO" 
      class="optimization" 
      regexp="-xO\d+\b">
<example>-xO&lt;n&gt;</example>
<![CDATA[
<p> Specify optimization level <kbd>n</kbd>: </p>
<ul>
  <li><kbd>-xO1</kbd> does only basic local optimizations (peephole.)</li>
  <li><kbd>-xO2</kbd> Do basic local and global optimizations, such as induction variable elimination, common subexpression
  elimination, constant propogation, register allocation, and basic block merging.</li>
  <li><kbd>-xO3</kbd> Add global optimizations at the function level, loop unrolling, and software pipelining.</li>
  <li><kbd>-xO4</kbd> Adds automatic inlining of functions in the same file.</li>
  <li><kbd>-xO5</kbd> Uses optmization algorithms that may take significantly more compilation time or that do not have as
  high a probability of improving execution time, such as speculative code motion.</li>
</ul>
]]>
</flag>


<flag name="xopenmp"
   class="optimization" 
   regexp="-xopenmp|-fopenmp"
   parallel="yes" >
   <example>-xopenmp or -fopenmp</example>
   Enable explicit parallelization with OpenMP directives.
</flag>


<flag name="xpad_common" 
      class="optimization" 
      regexp="-xpad=common(?::\d+)?\b" 
      compilers="oracle_studio_f90">
<example>-xpad=common[:&lt;n&gt;]</example>
<![CDATA[
<p> If multiple arrays are placed in common, insert padding between them for better use of cache.  <tt>n</tt> specifies the
amount of padding to apply, in units that are the same size as the array elements.  If no parameter is specified then the
compiler selects one automatically.  </p>
]]>
</flag>

<flag name="F-xpad:local" 
      class="optimization" 
      compilers="oracle_studio_f90">
Pad local variables, for better use of cache.
</flag>

<flag name="xpagesize" 
      class="optimization" 
      regexp="-xpagesize=\S+\b">
<example>-xpagesize=&lt;n&gt;</example>
Set the preferred page size for running the program.
</flag>

<flag name="xpagesize_heap" 
      class="optimization" 
      regexp="-xpagesize_heap=\S+\b" >
<example>-xpagesize_heap=&lt;n&gt;</example>
Set the preferred heap page size for running the program.
</flag>

<flag name="xpagesize_stack" 
      class="optimization" 
      regexp="-xpagesize_stack=\S+\b" >
<example>-xpagesize_stack=&lt;n&gt;</example>
Set the preferred stack page size for running the program.
</flag>

<flag name="xprefetch" 
      class="optimization" 
      regexp="-xprefetch=(auto|no%auto|explicit|no%explicit|yes|no|auto,explicit)\b">
<example>-xprefetch=auto,explicit</example>
<![CDATA[
<p> Control generation of prefetch instructions.  </p>
<ul>
<li><kbd>auto</kbd> enables automatic generation of prefetch instructions.</li>
<li><kbd>no%auto</kbd> disables automatic generation of prefetch instructions.</li>
<li><kbd>explicit</kbd> enables explicit prefetch macros. </li>
<li><kbd>no%explicit</kbd> disables explicit prefetch macros. </li>
<li><kbd>-xprefetch=yes</kbd> and <kbd>-xprefetch</kbd> are synonyms for <kbd>-xprefetch=auto,explicit</kbd>. </li> 
<li><kbd>-xprefetch=no</kbd> is a synonym for <kbd>-xprefetch=no%auto,no%explicit</kbd>.</li>
</ul>
<p>(Explicit prefetch macros are not used in the source code of the SPEC CPU benchmarks; therefore, in the context 
of SPEC CPU, <kbd>-xprefetch=yes</kbd> is effectively a synonym for <kbd>-xprefetch=auto</kbd>.)</p>
]]>
</flag>

<flag name="F-xprefetch_auto_type:indirect_array_access"
            class="optimization">
Generate indirect prefetches for data arrays accessed indirectly.
</flag>

<flag name="xprefetch_latx" 
      class="optimization" 
      regexp="-xprefetch=latx:\S+\b">
<example>-xprefetch=latx:&lt;n&gt;</example>
Adjust the compiler's assumptions about prefetch latency by the specified factor.  Typically values in the range of 0.5
to 2.0 will be useful.  A lower number might indicate that data will usually be cache resident; a higher number might
indicate a relatively larger gap between the processor speed and the memory speed (compared to the assumptions built into the
compiler).
</flag>


<flag name="xprefetch_level" 
      class="optimization" 
      regexp="-xprefetch_level=[123]\b">
<example>-xprefetch_level=&lt;n&gt;</example>
<![CDATA[
<p> Control the level of searching that the compiler does for prefetch opportunities by setting <kbd>n</kbd> to 1, 2, or 3,
where higher numbers mean to do more searching.  The default for Oracle Developer Studio C and Oracle Developer Studio C++ is 1.
The default for Oracle Developer Studio Fortran is 2. 
</p>
]]>
</flag>

<flag name="xprofile_collect" 
      class="optimization" 
      regexp="-xprofile=collect(:\S+)?\b">
<example>-xprofile=collect[:directory]</example>
<![CDATA[

<p>Collect profile data for feedback-directed optimization.  If an option  directory is named, the feedback will be stored
there.</p>

<p>When FDO is used, the training run gathers information regarding execution paths and data values.  Hardware performance
counters are not used.  FDO improves existing optimizations but does not introduce new classes of optimization.</p>

]]>

</flag>

<flag name="xprofile_use" 
      class="optimization" 
      regexp="-xprofile=use(:\S+)?\b">
<example>-xprofile=use[:directory]</example>
Use data collected for profile feedback.  If an option directory is named, look for the feedback data there.
</flag>

<flag name="F-xprofile_ircache" 
      class="optimization">
      regexp="-xprofile=use(:\S+)?\b">
Use -xprofile_ircache with -xprofile=collect|use to improve compilation time during the use phase by reusing compilation data saved from the collect phase.
</flag>

<flag name="F-xreduction" 
      class="optimization"
      parallel="yes" >
Analyze loops for reductions such as dot products, maximum and minimum finding.
</flag>

<flag name="F-xrestrict" 
      class="optimization">
Treat pointer-valued function parameters as restricted pointers. 
</flag>

<flag name="F-xsafe:mem" 
      class="optimization" >
<![CDATA[
<p> Enables the use of non-faulting loads when used in conjunction with <b><kbd>-xarch=v8plus</kbd></b>. Assumes that no
memory based traps will occur.  </p>
]]>
</flag>

<flag name="xsegmentalign" 
      class="optimization" 
      regexp="-xsegment_align=\S+\b">
<example>-xsegment_align&lt;n&gt;</example>
Causes the driver to include a special mapfile on the link line.
The mapfile aligns the text, data, and bss segments to the value specified by n.
</flag>

<flag name="xtarget" 
      class="optimization" 
      regexp="-xtarget=(\S+)\b">
<include flag="xarch" />
<include flag="xcache" />
<include flag="xchip" />
<example>-xtarget=native, or -xtarget=(some specific target)</example>
<![CDATA[
<p>Selects options for architecture, chip timing, and cache sizes.  These can also be controlled separately, via
<tt>-xarch</tt>, <tt>-xchip</tt>, and <tt>-xcache</tt>, respectively.  A wide variety of targets can be selected, including
ultraT2plus, T4, T5, T7, M5, M6, M7, sparc64viiplus, sparc64x, sparc64xplus, sparc64xii .  In each case, appropriate options
are selected for architecture, chip timing, and cache size to match that target.  </p>

<p>If <tt>-xtarget=native</tt> is selected, options that are appropriate for the system where the compile is being done.  
</p>

<p>The default is <tt>-xtarget=generic</tt>, which sets the parameters for the best performance over most 32-bit platform
architectures.  </p>

<p>On Solaris SPARC systems, the default pointer size with <tt>-xtarget=native</tt> is 32-bit.</p>
]]>
</flag>


<flag name="xthroughput"
      class="optimization" 
      regexp="-xthroughput=no|-xthroughput=yes|-xthroughput|-W2,-xthroughput=yes|-Wc,-xthroughput\b">
<example>-xthroughput=yes</example>
Prefer optimization for high throughput situations where memory is already heavily loaded, 
and the number of prefetches should therefore not be excessive.
<![CDATA[
<ul>
<li><kbd>yes</kbd> means that the compiler will favor optimizations that slightly reduce performance for a single process while improving the amount of work achieved by all the processes on the system.</li>
<li><kbd>no</kbd> is the default. The compiler does not reduce performance.</li>
</ul>
]]>
</flag>


<flag name="xunroll" 
      class="optimization" 
      regexp="-xunroll=\d+\b">
<example>-xunroll=&lt;n&gt;</example>
Enable unrolling loops n times where possible.
</flag>

<flag name="xvector" 
      class="optimization" 
      regexp="-xvector=(lib|no%lib|simd|no%simd|%none)\b">
<example>-xvector, -xvector=lib, -xvector=no%lib</example>
<![CDATA[
<p> Controll the vector math library.  </p>
<ul>
<li><kbd>lib</kbd> allows the compiler to transform math library calls within loops into calls to the vector math library.</li>
<li><kbd>no%lib</kbd> does not allow the compiler to transform math library calls within loops into calls to the vector math library.</li>
<li><kbd>simd</kbd> directs the compiler to use floating point and integer SIMD instructions.</li>
<li><kbd>no%simd</kbd> does not directs the compiler to use floating point and integer SIMD instructions.</li>
<li><kbd>%none</kbd> disables this option entirely.</li>
</ul>
<kbd>-xvector</kbd> is equivalent to <kbd>-xvector=lib</kbd>.
]]>
</flag>

</flagsdescription>
